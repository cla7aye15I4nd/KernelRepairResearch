id: 38b3aa8cd529958bd27a
bug_link: https://syzkaller.appspot.com/bug?extid=38b3aa8cd529958bd27a
title: possible deadlock in unix_notinflight
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: be0384bf599cf1eb8d337517feeb732d71f75a6f
fix_commit: b46f4eaa4f0ec38909fb0072eea3aeddb32f954e
datetime: '2024-04-08T19:58:48-07:00'
fix_commit_message: "af_unix: Clear stale u->oob_skb.\n\nsyzkaller started to report\
  \ deadlock of unix_gc_lock after commit\n4090fa373f0e (\"af_unix: Replace garbage\
  \ collection algorithm.\"), but\nit just uncovers the bug that has been there since\
  \ commit 314001f0bf92\n(\"af_unix: Add OOB support\").\n\nThe repro basically does\
  \ the following.\n\n  from socket import *\n  from array import array\n\n  c1, c2\
  \ = socketpair(AF_UNIX, SOCK_STREAM)\n  c1.sendmsg([b'a'], [(SOL_SOCKET, SCM_RIGHTS,\
  \ array(\"i\", [c2.fileno()]))], MSG_OOB)\n  c2.recv(1)  # blocked as no normal\
  \ data in recv queue\n\n  c2.close()  # done async and unblock recv()\n  c1.close()\
  \  # done async and trigger GC\n\nA socket sends its file descriptor to itself as\
  \ OOB data and tries to\nreceive normal data, but finally recv() fails due to async\
  \ close().\n\nThe problem here is wrong handling of OOB skb in manage_oob().  When\n\
  recvmsg() is called without MSG_OOB, manage_oob() is called to check\nif the peeked\
  \ skb is OOB skb.  In such a case, manage_oob() pops it\nout of the receive queue\
  \ but does not clear unix_sock(sk)->oob_skb.\nThis is wrong in terms of uAPI.\n\n\
  Let's say we send \"hello\" with MSG_OOB, and \"world\" without MSG_OOB.\nThe 'o'\
  \ is handled as OOB data.  When recv() is called twice without\nMSG_OOB, the OOB\
  \ data should be lost.\n\n  >>> from socket import *\n  >>> c1, c2 = socketpair(AF_UNIX,\
  \ SOCK_STREAM, 0)\n  >>> c1.send(b'hello', MSG_OOB)  # 'o' is OOB data\n  5\n  >>>\
  \ c1.send(b'world')\n  5\n  >>> c2.recv(5)  # OOB data is not received\n  b'hell'\n\
  \  >>> c2.recv(5)  # OOB date is skipped\n  b'world'\n  >>> c2.recv(5, MSG_OOB)\
  \  # This should return an error\n  b'o'\n\nIn the same situation, TCP actually\
  \ returns -EINVAL for the last\nrecv().\n\nAlso, if we do not clear unix_sk(sk)->oob_skb,\
  \ unix_poll() always set\nEPOLLPRI even though the data has passed through by previous\
  \ recv().\n\nTo avoid these issues, we must clear unix_sk(sk)->oob_skb when dequeuing\n\
  it from recv queue.\n\nThe reason why the old GC did not trigger the deadlock is\
  \ because the\nold GC relied on the receive queue to detect the loop.\n\nWhen it\
  \ is triggered, the socket with OOB data is marked as GC candidate\nbecause file\
  \ refcount == inflight count (1).  However, after traversing\nall inflight sockets,\
  \ the socket still has a positive inflight count (1),\nthus the socket is excluded\
  \ from candidates.  Then, the old GC lose the\nchance to garbage-collect the socket.\n\
  \nWith the old GC, the repro continues to create true garbage that will\nnever be\
  \ freed nor detected by kmemleak as it's linked to the global\ninflight list.  That's\
  \ why we couldn't even notice the issue.\n\nFixes: 314001f0bf92 (\"af_unix: Add\
  \ OOB support\")\nReported-by: syzbot+7f7f201cc2668a8fd169@syzkaller.appspotmail.com\n\
  Closes: https://syzkaller.appspot.com/bug?extid=7f7f201cc2668a8fd169\nSigned-off-by:\
  \ Kuniyuki Iwashima <kuniyu@amazon.com>\nReviewed-by: Eric Dumazet <edumazet@google.com>\n\
  Link: https://lore.kernel.org/r/20240405221057.2406-1-kuniyu@amazon.com\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n"
submodule:
- net/unix
hunk_count: 1
covered_count: 0
