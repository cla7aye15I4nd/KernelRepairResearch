id: 7574ebfe589049630608
bug_link: https://syzkaller.appspot.com/bug?extid=7574ebfe589049630608
title: WARNING in iommufd_access_destroy
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 6eaae198076080886b9e7d57f4ae06fa782f90ef
fix_commit: 99f98a7c0d6985d5507c8130a981972e4b7b3bdc
datetime: '2023-07-27T11:27:19-03:00'
fix_commit_message: "iommufd: IOMMUFD_DESTROY should not increase the refcount\n\n\
  syzkaller found a race where IOMMUFD_DESTROY increments the refcount:\n\n      \
  \ obj = iommufd_get_object(ucmd->ictx, cmd->id, IOMMUFD_OBJ_ANY);\n       if (IS_ERR(obj))\n\
  \               return PTR_ERR(obj);\n       iommufd_ref_to_users(obj);\n      \
  \ /* See iommufd_ref_to_users() */\n       if (!iommufd_object_destroy_user(ucmd->ictx,\
  \ obj))\n\nAs part of the sequence to join the two existing primitives together.\n\
  \nAllowing the refcount the be elevated without holding the destroy_rwsem\nviolates\
  \ the assumption that all temporary refcount elevations are\nprotected by destroy_rwsem.\
  \ Racing IOMMUFD_DESTROY with\niommufd_object_destroy_user() will cause spurious\
  \ failures:\n\n  WARNING: CPU: 0 PID: 3076 at drivers/iommu/iommufd/device.c:477\
  \ iommufd_access_destroy+0x18/0x20 drivers/iommu/iommufd/device.c:478\n  Modules\
  \ linked in:\n  CPU: 0 PID: 3076 Comm: syz-executor.0 Not tainted 6.3.0-rc1-syzkaller\
  \ #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS\
  \ Google 07/03/2023\n  RIP: 0010:iommufd_access_destroy+0x18/0x20 drivers/iommu/iommufd/device.c:477\n\
  \  Code: e8 3d 4e 00 00 84 c0 74 01 c3 0f 0b c3 0f 1f 44 00 00 f3 0f 1e fa 48 89\
  \ fe 48 8b bf a8 00 00 00 e8 1d 4e 00 00 84 c0 74 01 c3 <0f> 0b c3 0f 1f 44 00 00\
  \ 41 57 41 56 41 55 4c 8d ae d0 00 00 00 41\n  RSP: 0018:ffffc90003067e08 EFLAGS:\
  \ 00010246\n  RAX: 0000000000000000 RBX: ffff888109ea0300 RCX: 0000000000000000\n\
  \  RDX: 0000000000000001 RSI: 0000000000000000 RDI: 00000000ffffffff\n  RBP: 0000000000000004\
  \ R08: 0000000000000000 R09: ffff88810bbb3500\n  R10: ffff88810bbb3e48 R11: 0000000000000000\
  \ R12: ffffc90003067e88\n  R13: ffffc90003067ea8 R14: ffff888101249800 R15: 00000000fffffffe\n\
  \  FS:  00007ff7254fe6c0(0000) GS:ffff888237c00000(0000) knlGS:0000000000000000\n\
  \  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000555557262da8 CR3:\
  \ 000000010a6fd000 CR4: 0000000000350ef0\n  Call Trace:\n   <TASK>\n   iommufd_test_create_access\
  \ drivers/iommu/iommufd/selftest.c:596 [inline]\n   iommufd_test+0x71c/0xcf0 drivers/iommu/iommufd/selftest.c:813\n\
  \   iommufd_fops_ioctl+0x10f/0x1b0 drivers/iommu/iommufd/main.c:337\n   vfs_ioctl\
  \ fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:870 [inline]\n   __se_sys_ioctl\
  \ fs/ioctl.c:856 [inline]\n   __x64_sys_ioctl+0x84/0xc0 fs/ioctl.c:856\n   do_syscall_x64\
  \ arch/x86/entry/common.c:50 [inline]\n   do_syscall_64+0x38/0x80 arch/x86/entry/common.c:80\n\
  \   entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThe solution is to not increment\
  \ the refcount on the IOMMUFD_DESTROY path\nat all. Instead use the xa_lock to serialize\
  \ everything. The refcount\ncheck == 1 and xa_erase can be done under a single critical\
  \ region. This\navoids the need for any refcount incrementing.\n\nIt has the downside\
  \ that if userspace races destroy with other operations\nit will get an EBUSY instead\
  \ of waiting, but this is kind of racing is\nalready dangerous.\n\nFixes: 2ff4bed7fee7\
  \ (\"iommufd: File descriptor, context, kconfig and makefiles\")\nLink: https://lore.kernel.org/r/2-v1-85aacb2af554+bc-iommufd_syz3_jgg@nvidia.com\n\
  Reviewed-by: Kevin Tian <kevin.tian@intel.com>\nReported-by: syzbot+7574ebfe589049630608@syzkaller.appspotmail.com\n\
  Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>\n"
submodule:
- drivers/iommu/iommufd
hunk_count: 7
covered_count: 1
