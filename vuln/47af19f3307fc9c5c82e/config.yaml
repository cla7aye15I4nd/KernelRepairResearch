id: 47af19f3307fc9c5c82e
bug_link: https://syzkaller.appspot.com/bug?extid=47af19f3307fc9c5c82e
title: 'KASAN: use-after-free Read in tipc_named_reinit (2)'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: e66e257a5d8368d9c0ba13d4630f474436533e8b
fix_commit: 911600bf5a5e84bfda4d33ee32acc75ecf6159f0
datetime: '2022-06-17T11:39:10+01:00'
fix_commit_message: "tipc: fix use-after-free Read in tipc_named_reinit\n\nsyzbot\
  \ found the following issue on:\n==================================================================\n\
  BUG: KASAN: use-after-free in tipc_named_reinit+0x94f/0x9b0\nnet/tipc/name_distr.c:413\n\
  Read of size 8 at addr ffff88805299a000 by task kworker/1:9/23764\n\nCPU: 1 PID:\
  \ 23764 Comm: kworker/1:9 Not tainted\n5.18.0-rc4-syzkaller-00878-g17d49e6e8012\
  \ #0\nHardware name: Google Compute Engine/Google Compute Engine,\nBIOS Google 01/01/2011\n\
  Workqueue: events tipc_net_finalize_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88\
  \ [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n print_address_description.constprop.0.cold+0xeb/0x495\n\
  mm/kasan/report.c:313\n print_report mm/kasan/report.c:429 [inline]\n kasan_report.cold+0xf4/0x1c6\
  \ mm/kasan/report.c:491\n tipc_named_reinit+0x94f/0x9b0 net/tipc/name_distr.c:413\n\
  \ tipc_net_finalize+0x234/0x3d0 net/tipc/net.c:138\n process_one_work+0x996/0x1610\
  \ kernel/workqueue.c:2289\n worker_thread+0x665/0x1080 kernel/workqueue.c:2436\n\
  \ kthread+0x2e9/0x3a0 kernel/kthread.c:376\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:298\n\
  \ </TASK>\n[...]\n==================================================================\n\
  \nIn the commit\nd966ddcc3821 (\"tipc: fix a deadlock when flushing scheduled work\"\
  ),\nthe cancel_work_sync() function just to make sure ONLY the work\ntipc_net_finalize_work()\
  \ is executing/pending on any CPU completed before\ntipc namespace is destroyed\
  \ through tipc_exit_net(). But this function\nis not guaranteed the work is the\
  \ last queued. So, the destroyed instance\nmay be accessed in the work which will\
  \ try to enqueue later.\n\nIn order to completely fix, we re-order the calling of\
  \ cancel_work_sync()\nto make sure the work tipc_net_finalize_work() was last queued\
  \ and it\nmust be completed by calling cancel_work_sync().\n\nReported-by: syzbot+47af19f3307fc9c5c82e@syzkaller.appspotmail.com\n\
  Fixes: d966ddcc3821 (\"tipc: fix a deadlock when flushing scheduled work\")\nAcked-by:\
  \ Jon Maloy <jmaloy@redhat.com>\nSigned-off-by: Ying Xue <ying.xue@windriver.com>\n\
  Signed-off-by: Hoang Le <hoang.h.le@dektech.com.au>\nSigned-off-by: David S. Miller\
  \ <davem@davemloft.net>\n"
submodule:
- net/tipc
hunk_count: 1
covered_count: 1
