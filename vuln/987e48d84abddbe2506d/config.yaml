id: 987e48d84abddbe2506d
bug_link: https://syzkaller.appspot.com/bug?extid=987e48d84abddbe2506d
title: WARNING in bpf_prog_kallsyms_add
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 6754172c208d9d3dae208c6494611ac167d56688
fix_commit: c751798aa224fadc5124b49eeb38fb468c0fa039
datetime: '2019-08-24T01:17:47+02:00'
fix_commit_message: "bpf: fix use after free in prog symbol exposure\n\nsyzkaller\
  \ managed to trigger the warning in bpf_jit_free() which checks via\nbpf_prog_kallsyms_verify_off()\
  \ for potentially unlinked JITed BPF progs\nin kallsyms, and subsequently trips\
  \ over GPF when walking kallsyms entries:\n\n  [...]\n  8021q: adding VLAN 0 to\
  \ HW filter on device batadv0\n  8021q: adding VLAN 0 to HW filter on device batadv0\n\
  \  WARNING: CPU: 0 PID: 9869 at kernel/bpf/core.c:810 bpf_jit_free+0x1e8/0x2a0\n\
  \  Kernel panic - not syncing: panic_on_warn set ...\n  CPU: 0 PID: 9869 Comm: kworker/0:7\
  \ Not tainted 5.0.0-rc8+ #1\n  Hardware name: Google Google Compute Engine/Google\
  \ Compute Engine, BIOS Google 01/01/2011\n  Workqueue: events bpf_prog_free_deferred\n\
  \  Call Trace:\n   __dump_stack lib/dump_stack.c:77 [inline]\n   dump_stack+0x113/0x167\
  \ lib/dump_stack.c:113\n   panic+0x212/0x40b kernel/panic.c:214\n   __warn.cold.8+0x1b/0x38\
  \ kernel/panic.c:571\n   report_bug+0x1a4/0x200 lib/bug.c:186\n   fixup_bug arch/x86/kernel/traps.c:178\
  \ [inline]\n   do_error_trap+0x11b/0x200 arch/x86/kernel/traps.c:271\n   do_invalid_op+0x36/0x40\
  \ arch/x86/kernel/traps.c:290\n   invalid_op+0x14/0x20 arch/x86/entry/entry_64.S:973\n\
  \  RIP: 0010:bpf_jit_free+0x1e8/0x2a0\n  Code: 02 4c 89 e2 83 e2 07 38 d0 7f 08\
  \ 84 c0 0f 85 86 00 00 00 48 ba 00 02 00 00 00 00 ad de 0f b6 43 02 49 39 d6 0f\
  \ 84 5f fe ff ff <0f> 0b e9 58 fe ff ff 48 b8 00 00 00 00 00 fc ff df 4c 89 e2 48\
  \ c1\n  RSP: 0018:ffff888092f67cd8 EFLAGS: 00010202\n  RAX: 0000000000000007 RBX:\
  \ ffffc90001947000 RCX: ffffffff816e9d88\n  RDX: dead000000000200 RSI: 0000000000000008\
  \ RDI: ffff88808769f7f0\n  RBP: ffff888092f67d00 R08: fffffbfff1394059 R09: fffffbfff1394058\n\
  \  R10: fffffbfff1394058 R11: ffffffff89ca02c7 R12: ffffc90001947002\n  R13: ffffc90001947020\
  \ R14: ffffffff881eca80 R15: ffff88808769f7e8\n  BUG: unable to handle kernel paging\
  \ request at fffffbfff400d000\n  #PF error: [normal kernel read fault]\n  PGD 21ffee067\
  \ P4D 21ffee067 PUD 21ffed067 PMD 9f942067 PTE 0\n  Oops: 0000 [#1] PREEMPT SMP\
  \ KASAN\n  CPU: 0 PID: 9869 Comm: kworker/0:7 Not tainted 5.0.0-rc8+ #1\n  Hardware\
  \ name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n\
  \  Workqueue: events bpf_prog_free_deferred\n  RIP: 0010:bpf_get_prog_addr_region\
  \ kernel/bpf/core.c:495 [inline]\n  RIP: 0010:bpf_tree_comp kernel/bpf/core.c:558\
  \ [inline]\n  RIP: 0010:__lt_find include/linux/rbtree_latch.h:115 [inline]\n  RIP:\
  \ 0010:latch_tree_find include/linux/rbtree_latch.h:208 [inline]\n  RIP: 0010:bpf_prog_kallsyms_find+0x107/0x2e0\
  \ kernel/bpf/core.c:632\n  Code: 00 f0 ff ff 44 38 c8 7f 08 84 c0 0f 85 fa 00 00\
  \ 00 41 f6 45 02 01 75 02 0f 0b 48 39 da 0f 82 92 00 00 00 48 89 d8 48 c1 e8 03\
  \ <42> 0f b6 04 30 84 c0 74 08 3c 03 0f 8e 45 01 00 00 8b 03 48 c1 e0\n  [...]\n\
  \nUpon further debugging, it turns out that whenever we trigger this\nissue, the\
  \ kallsyms removal in bpf_prog_ksym_node_del() was /skipped/\nbut yet bpf_jit_free()\
  \ reported that the entry is /in use/.\n\nProblem is that symbol exposure via bpf_prog_kallsyms_add()\
  \ but also\nperf_event_bpf_event() were done /after/ bpf_prog_new_fd(). Once the\n\
  fd is exposed to the public, a parallel close request came in right\nbefore we attempted\
  \ to do the bpf_prog_kallsyms_add().\n\nGiven at this time the prog reference count\
  \ is one, we start to rip\neverything underneath us via bpf_prog_release() -> bpf_prog_put().\n\
  The memory is eventually released via deferred free, so we're seeing\nthat bpf_jit_free()\
  \ has a kallsym entry because we added it from\nbpf_prog_load() but /after/ bpf_prog_put()\
  \ from the remote CPU.\n\nTherefore, move both notifications /before/ we install\
  \ the fd. The\nissue was never seen between bpf_prog_alloc_id() and bpf_prog_new_fd()\n\
  because upon bpf_prog_get_fd_by_id() we'll take another reference to\nthe BPF prog,\
  \ so we're still holding the original reference from the\nbpf_prog_load().\n\nFixes:\
  \ 6ee52e2a3fe4 (\"perf, bpf: Introduce PERF_RECORD_BPF_EVENT\")\nFixes: 74451e66d516\
  \ (\"bpf: make jited programs visible in traces\")\nReported-by: syzbot+bd3bba6ff3fcea7a6ec6@syzkaller.appspotmail.com\n\
  Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>\nCc: Song Liu <songliubraving@fb.com>\n"
submodule:
- kernel/bpf
hunk_count: 1
covered_count: 0
