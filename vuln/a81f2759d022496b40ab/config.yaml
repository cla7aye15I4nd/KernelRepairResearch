id: a81f2759d022496b40ab
bug_link: https://syzkaller.appspot.com/bug?extid=a81f2759d022496b40ab
title: 'KMSAN: uninit-value in hsr_get_node (3)'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 2c2192e5f9c7c2892fe2363244d1387f62710d83
fix_commit: 7af76e9d18a9fd6f8611b3313c86c190f9b6a5a7
datetime: '2025-08-20T19:31:25-07:00'
fix_commit_message: "net, hsr: reject HSR frame if skb can't hold tag\n\nReceiving\
  \ HSR frame with insufficient space to hold HSR tag in the skb\ncan result in a\
  \ crash (kernel BUG):\n\n[   45.390915] skbuff: skb_under_panic: text:ffffffff86f32cac\
  \ len:26 put:14 head:ffff888042418000 data:ffff888042417ff4 tail:0xe end:0x180 dev:bridge_slave_1\n\
  [   45.392559] ------------[ cut here ]------------\n[   45.392912] kernel BUG at\
  \ net/core/skbuff.c:211!\n[   45.393276] Oops: invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC\
  \ KASAN NOPTI\n[   45.393809] CPU: 1 UID: 0 PID: 2496 Comm: reproducer Not tainted\
  \ 6.15.0 #12 PREEMPT(undef)\n[   45.394433] Hardware name: QEMU Standard PC (i440FX\
  \ + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n\
  [   45.395273] RIP: 0010:skb_panic+0x15b/0x1d0\n\n<snip registers, remove unreliable\
  \ trace>\n\n[   45.402911] Call Trace:\n[   45.403105]  <IRQ>\n[   45.404470]  skb_push+0xcd/0xf0\n\
  [   45.404726]  br_dev_queue_push_xmit+0x7c/0x6c0\n[   45.406513]  br_forward_finish+0x128/0x260\n\
  [   45.408483]  __br_forward+0x42d/0x590\n[   45.409464]  maybe_deliver+0x2eb/0x420\n\
  [   45.409763]  br_flood+0x174/0x4a0\n[   45.410030]  br_handle_frame_finish+0xc7c/0x1bc0\n\
  [   45.411618]  br_handle_frame+0xac3/0x1230\n[   45.413674]  __netif_receive_skb_core.constprop.0+0x808/0x3df0\n\
  [   45.422966]  __netif_receive_skb_one_core+0xb4/0x1f0\n[   45.424478]  __netif_receive_skb+0x22/0x170\n\
  [   45.424806]  process_backlog+0x242/0x6d0\n[   45.425116]  __napi_poll+0xbb/0x630\n\
  [   45.425394]  net_rx_action+0x4d1/0xcc0\n[   45.427613]  handle_softirqs+0x1a4/0x580\n\
  [   45.427926]  do_softirq+0x74/0x90\n[   45.428196]  </IRQ>\n\nThis issue was found\
  \ by syzkaller.\n\nThe panic happens in br_dev_queue_push_xmit() once it receives\
  \ a\ncorrupted skb with ETH header already pushed in linear data. When it\nattempts\
  \ the skb_push() call, there's not enough headroom and\nskb_push() panics.\n\nThe\
  \ corrupted skb is put on the queue by HSR layer, which makes a\nsequence of unintended\
  \ transformations when it receives a specific\ncorrupted HSR frame (with incomplete\
  \ TAG).\n\nFix it by dropping and consuming frames that are not long enough to\n\
  contain both ethernet and hsr headers.\n\nAlternative fix would be to check for\
  \ enough headroom before skb_push()\nin br_dev_queue_push_xmit().\n\nIn the reproducer,\
  \ this is injected via AF_PACKET, but I don't easily\nsee why it couldn't be sent\
  \ over the wire from adjacent network.\n\nFurther Details:\n\nIn the reproducer,\
  \ the following network interface chain is set up:\n\n┌────────────────┐   ┌────────────────┐\n\
  │ veth0_to_hsr   ├───┤  hsr_slave0    ┼───┐\n└────────────────┘   └────────────────┘\
  \   │\n                                          │ ┌──────┐\n                  \
  \                        ├─┤ hsr0 ├───┐\n                                      \
  \    │ └──────┘   │\n┌────────────────┐   ┌────────────────┐   │            │┌────────┐\n\
  │ veth1_to_hsr   ┼───┤  hsr_slave1    ├───┘            └┤        │\n└────────────────┘\
  \   └────────────────┘                ┌┼ bridge │\n                            \
  \                           ││        │\n                                      \
  \                 │└────────┘\n                                                \
  \       │\n                                        ┌───────┐      │\n          \
  \                              │  ...  ├──────┘\n                              \
  \          └───────┘\n\nTo trigger the events leading up to crash, reproducer sends\
  \ a corrupted\nHSR frame with incomplete TAG, via AF_PACKET socket on 'veth0_to_hsr'.\n\
  \nThe first HSR-layer function to process this frame is\nhsr_handle_frame(). It\
  \ and then checks if the\nprotocol is ETH_P_PRP or ETH_P_HSR. If it is, it calls\n\
  skb_set_network_header(skb, ETH_HLEN + HSR_HLEN), without checking that\nthe skb\
  \ is long enough. For the crashing frame it is not, and hence the\nskb->network_header\
  \ and skb->mac_len fields are set incorrectly,\npointing after the end of the linear\
  \ buffer.\n\nI will call this a BUG#1 and it is what is addressed by this patch.\
  \ In\nthe crashing scenario before the fix, the skb continues to go down the\nhsr\
  \ path as follows.\n\nhsr_handle_frame() then calls this sequence\nhsr_forward_skb()\n\
  \  fill_frame_info()\n    hsr->proto_ops->fill_frame_info()\n      hsr_fill_frame_info()\n\
  \nhsr_fill_frame_info() contains a check that intends to check whether the\nskb\
  \ actually contains the HSR header. But the check relies on the\nskb->mac_len field\
  \ which was erroneously setup due to BUG#1, so the\ncheck passes and the execution\
  \ continues  back in the hsr_forward_skb():\n\nhsr_forward_skb()\n  hsr_forward_do()\n\
  \    hsr->proto_ops->get_untagged_frame()\n      hsr_get_untagged_frame()\n    \
  \    create_stripped_skb_hsr()\n\nIn create_stripped_skb_hsr(), a copy of the skb\
  \ is created and is\nfurther corrupted by operation that attempts to strip the HSR\
  \ tag in a\ncall to __pskb_copy().\n\nThe skb enters create_stripped_skb_hsr() with\
  \ ethernet header pushed in\nlinear buffer. The skb_pull(skb_in, HSR_HLEN) thus\
  \ pulls 6 bytes of\nethernet header into the headroom, creating skb_in with a headroom\
  \ of\nsize 8. The subsequent __pskb_copy() then creates an skb with headroom\nof\
  \ just 2 and skb->len of just 12, this is how it looks after the copy:\n\ngdb) p\
  \ skb->len\n$10 = 12\n(gdb) p skb->data\n$11 = (unsigned char *) 0xffff888041e45382\
  \ \"\\252\\252\\252\\252\\252!\\210\\373\",\n(gdb) p skb->head\n$12 = (unsigned\
  \ char *) 0xffff888041e45380 \"\"\n\nIt seems create_stripped_skb_hsr() assumes\
  \ that ETH header is pulled\nin the headroom when it's entered, because it just\
  \ pulls HSR header on\ntop. But that is not the case in our code-path and we end\
  \ up with the\ncorrupted skb instead. I will call this BUG#2\n\n*I got confused\
  \ here because it seems that under no conditions can\ncreate_stripped_skb_hsr()\
  \ work well, the assumption it makes is not true\nduring the processing of hsr frames\
  \ - since the skb_push() in\nhsr_handle_frame to skb_pull in hsr_deliver_master().\
  \ I wonder whether I\nmissed something here.*\n\nNext, the execution arrives in\
  \ hsr_deliver_master(). It calls\nskb_pull(ETH_HLEN), which just returns NULL -\
  \ the SKB does not have\nenough space for the pull (as it only has 12 bytes in total\
  \ at this\npoint).\n\n*The skb_pull() here further suggests that ethernet header\
  \ is meant\nto be pushed through the whole hsr processing and\ncreate_stripped_skb_hsr()\
  \ should pull it before doing the HSR header\npull.*\n\nhsr_deliver_master() then\
  \ puts the corrupted skb on the queue, it is\nthen picked up from there by bridge\
  \ frame handling layer and finally\nlands in br_dev_queue_push_xmit where it panics.\n\
  \nCc: stable@kernel.org\nFixes: 48b491a5cc74 (\"net: hsr: fix mac_len checks\")\n\
  Reported-by: syzbot+a81f2759d022496b40ab@syzkaller.appspotmail.com\nSigned-off-by:\
  \ Jakub Acs <acsjakub@amazon.de>\nReviewed-by: Eric Dumazet <edumazet@google.com>\n\
  Link: https://patch.msgid.link/20250819082842.94378-1-acsjakub@amazon.de\nSigned-off-by:\
  \ Jakub Kicinski <kuba@kernel.org>\n"
submodule:
- net/hsr
hunk_count: 1
covered_count: 1
