id: 38a0cbd267eff2d286ff
bug_link: https://syzkaller.appspot.com/bug?extid=38a0cbd267eff2d286ff
title: WARNING in lock_list_lru_of_memcg
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 7d390b53067ef745e2d9bee5a9683df4c96b80a0
fix_commit: 62e72d2cf702a5e2fb53d9c46ed900d9384e4a06
datetime: '2024-12-30T17:59:11-08:00'
fix_commit_message: 'mm, madvise: fix potential workingset node list_lru leaks


  Since commit 5abc1e37afa0 ("mm: list_lru: allocate list_lru_one only when

  needed"), all list_lru users need to allocate the items using the new

  infrastructure that provides list_lru info for slab allocation, ensuring

  that the corresponding memcg list_lru is allocated before use.


  For workingset shadow nodes (which are xa_node), users are converted to

  use the new infrastructure by commit 9bbdc0f32409 ("xarray: use

  kmem_cache_alloc_lru to allocate xa_node").  The xas->xa_lru will be set

  correctly for filemap users.  However, there is a missing case: xa_node

  allocations caused by madvise(..., MADV_COLLAPSE).


  madvise(..., MADV_COLLAPSE) will also read in the absent parts of file

  map, and there will be xa_nodes allocated for the caller''s memcg (assuming

  it''s not rootcg).  However, these allocations won''t trigger memcg list_lru

  allocation because the proper xas info was not set.


  If nothing else has allocated other xa_nodes for that memcg to trigger

  list_lru creation, and memory pressure starts to evict file pages,

  workingset_update_node will try to add these xa_nodes to their

  corresponding memcg list_lru, and it does not exist (NULL).  So they will

  be added to rootcg''s list_lru instead.


  This shouldn''t be a significant issue in practice, but it is indeed

  unexpected behavior, and these xa_nodes will not be reclaimed effectively.

  And may lead to incorrect counting of the list_lru->nr_items counter.


  This problem wasn''t exposed until recent commit 28e98022b31ef

  ("mm/list_lru: simplify reparenting and initial allocation") added a

  sanity check: only dying memcg could have a NULL list_lru when

  list_lru_{add,del} is called.  This problem triggered this WARNING.


  So make madvise(..., MADV_COLLAPSE) also call xas_set_lru() to pass the

  list_lru which we may want to insert xa_node into later.  And move

  mapping_set_update to mm/internal.h, and turn into a macro to avoid

  including extra headers in mm/internal.h.


  Link: https://lkml.kernel.org/r/20241222122936.67501-1-ryncsn@gmail.com

  Fixes: 9bbdc0f32409 ("xarray: use kmem_cache_alloc_lru to allocate xa_node")

  Reported-by: syzbot+38a0cbd267eff2d286ff@syzkaller.appspotmail.com

  Closes: https://lore.kernel.org/lkml/675d01e9.050a0220.37aaf.00be.GAE@google.com/

  Signed-off-by: Kairui Song <kasong@tencent.com>

  Cc: Chengming Zhou <chengming.zhou@linux.dev>

  Cc: Johannes Weiner <hannes@cmpxchg.org>

  Cc: Matthew Wilcox (Oracle) <willy@infradead.org>

  Cc: Michal Hocko <mhocko@suse.com>

  Cc: Muchun Song <muchun.song@linux.dev>

  Cc: Qi Zheng <zhengqi.arch@bytedance.com>

  Cc: Roman Gushchin <roman.gushchin@linux.dev>

  Cc: Sasha Levin <sashal@kernel.org>

  Cc: Shakeel Butt <shakeel.butt@linux.dev>

  Cc: Yu Zhao <yuzhao@google.com>

  Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

  '
submodule:
- mm
hunk_count: 4
covered_count: 0
