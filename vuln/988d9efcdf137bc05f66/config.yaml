id: 988d9efcdf137bc05f66
bug_link: https://syzkaller.appspot.com/bug?extid=988d9efcdf137bc05f66
title: WARNING in vmx_handle_exit
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 1876dd69dfe8c29e249070b0e4dc941fc15ac1e4
fix_commit: 3f6821aa147b6e6fe07e8b35999724518b74a632
datetime: '2024-09-09T20:09:49-07:00'
fix_commit_message: "KVM: x86: Forcibly leave nested if RSM to L2 hits shutdown\n\n\
  Leave nested mode before synthesizing shutdown (a.k.a. TRIPLE_FAULT) if\nRSM fails\
  \ when resuming L2 (a.k.a. guest mode).  Architecturally, shutdown\non RSM occurs\
  \ _before_ the transition back to guest mode on both Intel and\nAMD.\n\nOn Intel,\
  \ per the SDM pseudocode, SMRAM state is loaded before critical\nVMX state:\n\n\
  \  restore state normally from SMRAM;\n  ...\n  CR4.VMXE := value stored internally;\n\
  \  IF internal storage indicates that the logical processor had been in\n     VMX\
  \ operation (root or non-root)\n  THEN\n     enter VMX operation (root or non-root);\n\
  \     restore VMX-critical state as defined in Section 32.14.1;\n     ...\n    \
  \ restore current VMCS pointer;\n  FI;\n\nAMD's APM is both less clearcut and more\
  \ explicit.  Because AMD CPUs save\nVMCB and guest state in SMRAM itself, given\
  \ the lack of anything in the\nAPM to indicate a shutdown in guest mode is possible,\
  \ a straightforward\nreading of the clause on invalid state is that _what_ state\
  \ is invalid is\nirrelevant, i.e. all roads lead to shutdown.\n\n  An RSM causes\
  \ a processor shutdown if an invalid-state condition is\n  found in the SMRAM state-save\
  \ area.\n\nThis fixes a bug found by syzkaller where synthesizing shutdown for L2\n\
  led to a nested VM-Exit (if L1 is intercepting shutdown), which in turn\ncaused\
  \ KVM to complain about trying to cancel a nested VM-Enter (see\ncommit 759cbd59674a\
  \ (\"KVM: x86: nSVM/nVMX: set nested_run_pending on VM\nentry which is a result\
  \ of RSM\").\n\nNote, Paolo pointed out that KVM shouldn't set nested_run_pending\
  \ until\nafter loading SMRAM state.  But as above, that's only half the story, KVM\n\
  shouldn't transition to guest mode either.  Unfortunately, fixing that\nmess requires\
  \ rewriting the nVMX and nSVM RSM flows to not piggyback\ntheir nested VM-Enter\
  \ flows, as executing the nested VM-Enter flows after\nloading state from SMRAM\
  \ would clobber much of said state.\n\nFor now, add a FIXME to call out that transitioning\
  \ to guest mode before\nloading state from SMRAM is wrong.\n\nLink: https://lore.kernel.org/all/CABgObfYaUHXyRmsmg8UjRomnpQ0Jnaog9-L2gMjsjkqChjDYUQ@mail.gmail.com\n\
  Reported-by: syzbot+988d9efcdf137bc05f66@syzkaller.appspotmail.com\nCloses: https://lore.kernel.org/all/0000000000007a9acb06151e1670@google.com\n\
  Reported-by: Zheyu Ma <zheyuma97@gmail.com>\nCloses: https://lore.kernel.org/all/CAMhUBjmXMYsEoVYw_M8hSZjBMHh24i88QYm-RY6HDta5YZ7Wgw@mail.gmail.com\n\
  Analyzed-by: Michal Wilczynski <michal.wilczynski@intel.com>\nCc: Kishen Maloor\
  \ <kishen.maloor@intel.com>\nReviewed-by: Maxim Levitsky <mlevitsk@redhat.com>\n\
  Link: https://lore.kernel.org/r/20240906161337.1118412-1-seanjc@google.com\nSigned-off-by:\
  \ Sean Christopherson <seanjc@google.com>\n"
submodule:
- arch/x86/kvm
hunk_count: 3
covered_count: 0
