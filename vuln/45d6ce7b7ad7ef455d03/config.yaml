id: 45d6ce7b7ad7ef455d03
bug_link: https://syzkaller.appspot.com/bug?extid=45d6ce7b7ad7ef455d03
title: possible deadlock in nilfs_count_free_blocks
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: cc674ab3c0188002917c8a2c28e4424131f1fd7e
fix_commit: 8ac932a4921a96ca52f61935dbba64ea87bbd5dc
datetime: '2022-11-08T15:57:23-08:00'
fix_commit_message: "nilfs2: fix deadlock in nilfs_count_free_blocks()\n\nA semaphore\
  \ deadlock can occur if nilfs_get_block() detects metadata\ncorruption while locating\
  \ data blocks and a superblock writeback occurs at\nthe same time:\n\ntask 1   \
  \                            task 2\n------                               ------\n\
  * A file operation *\nnilfs_truncate()\n  nilfs_get_block()\n    down_read(rwsem\
  \ A) <--\n    nilfs_bmap_lookup_contig()\n      ...                            generic_shutdown_super()\n\
  \                                       nilfs_put_super()\n                    \
  \                     * Prepare to write superblock *\n                        \
  \                 down_write(rwsem B) <--\n                                    \
  \     nilfs_cleanup_super()\n      * Detect b-tree corruption *         nilfs_set_log_cursor()\n\
  \      nilfs_bmap_convert_error()             nilfs_count_free_blocks()\n      \
  \  __nilfs_error()                        down_read(rwsem A) <--\n          nilfs_set_error()\n\
  \            down_write(rwsem B) <--\n\n                           *** DEADLOCK\
  \ ***\n\nHere, nilfs_get_block() readlocks rwsem A (= NILFS_MDT(dat_inode)->mi_sem)\n\
  and then calls nilfs_bmap_lookup_contig(), but if it fails due to metadata\ncorruption,\
  \ __nilfs_error() is called from nilfs_bmap_convert_error()\ninside the lock section.\n\
  \nSince __nilfs_error() calls nilfs_set_error() unless the filesystem is\nread-only\
  \ and nilfs_set_error() attempts to writelock rwsem B (=\nnilfs->ns_sem) to write\
  \ back superblock exclusively, hierarchical lock\nacquisition occurs in the order\
  \ rwsem A -> rwsem B.\n\nNow, if another task starts updating the superblock, it\
  \ may writelock\nrwsem B during the lock sequence above, and can deadlock trying\
  \ to\nreadlock rwsem A in nilfs_count_free_blocks().\n\nHowever, there is actually\
  \ no need to take rwsem A in\nnilfs_count_free_blocks() because it, within the lock\
  \ section, only reads\na single integer data on a shared struct with\nnilfs_sufile_get_ncleansegs().\
  \  This has been the case after commit\naa474a220180 (\"nilfs2: add local variable\
  \ to cache the number of clean\nsegments\"), that is, even before this bug was introduced.\n\
  \nSo, this resolves the deadlock problem by just not taking the semaphore in\nnilfs_count_free_blocks().\n\
  \nLink: https://lkml.kernel.org/r/20221029044912.9139-1-konishi.ryusuke@gmail.com\n\
  Fixes: e828949e5b42 (\"nilfs2: call nilfs_error inside bmap routines\")\nSigned-off-by:\
  \ Ryusuke Konishi <konishi.ryusuke@gmail.com>\nReported-by: syzbot+45d6ce7b7ad7ef455d03@syzkaller.appspotmail.com\n\
  Tested-by: Ryusuke Konishi <konishi.ryusuke@gmail.com>\nCc: <stable@vger.kernel.org>\t\
  [2.6.38+\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n"
submodule:
- fs/nilfs2
hunk_count: 1
covered_count: 1
