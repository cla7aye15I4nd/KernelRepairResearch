id: cef9473c7fa0fe8ab95e
bug_link: https://syzkaller.appspot.com/bug?extid=cef9473c7fa0fe8ab95e
title: 'KASAN: use-after-free Read in uprobe_perf_close'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: ce9f85c32678efd3ab9b8c9aade0f0ffed0016c5
fix_commit: 621b6d2ea297d0fb6030452c5bcd221f12165fcf
datetime: '2018-04-09T18:15:58+02:00'
fix_commit_message: "perf/core: Fix use-after-free in uprobe_perf_close()\n\nA use-after-free\
  \ bug was caught by KASAN while running usdt related\ncode (BCC project. bcc/tests/python/test_usdt2.py):\n\
  \n\t==================================================================\n\tBUG: KASAN:\
  \ use-after-free in uprobe_perf_close+0x222/0x3b0\n\tRead of size 4 at addr ffff880384f9b4a4\
  \ by task test_usdt2.py/870\n\n\tCPU: 4 PID: 870 Comm: test_usdt2.py Tainted: G\
  \        W         4.16.0-next-20180409 #215\n\tHardware name: QEMU Standard PC\
  \ (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n\tCall Trace:\n\t\
  \ dump_stack+0xc7/0x15b\n\t ? show_regs_print_info+0x5/0x5\n\t ? printk+0x9c/0xc3\n\
  \t ? kmsg_dump_rewind_nolock+0x6e/0x6e\n\t ? uprobe_perf_close+0x222/0x3b0\n\t print_address_description+0x83/0x3a0\n\
  \t ? uprobe_perf_close+0x222/0x3b0\n\t kasan_report+0x1dd/0x460\n\t ? uprobe_perf_close+0x222/0x3b0\n\
  \t uprobe_perf_close+0x222/0x3b0\n\t ? probes_open+0x180/0x180\n\t ? free_filters_list+0x290/0x290\n\
  \t trace_uprobe_register+0x1bb/0x500\n\t ? perf_event_attach_bpf_prog+0x310/0x310\n\
  \t ? probe_event_disable+0x4e0/0x4e0\n\t perf_uprobe_destroy+0x63/0xd0\n\t _free_event+0x2bc/0xbd0\n\
  \t ? lockdep_rcu_suspicious+0x100/0x100\n\t ? ring_buffer_attach+0x550/0x550\n\t\
  \ ? kvm_sched_clock_read+0x1a/0x30\n\t ? perf_event_release_kernel+0x3e4/0xc00\n\
  \t ? __mutex_unlock_slowpath+0x12e/0x540\n\t ? wait_for_completion+0x430/0x430\n\
  \t ? lock_downgrade+0x3c0/0x3c0\n\t ? lock_release+0x980/0x980\n\t ? do_raw_spin_trylock+0x118/0x150\n\
  \t ? do_raw_spin_unlock+0x121/0x210\n\t ? do_raw_spin_trylock+0x150/0x150\n\t perf_event_release_kernel+0x5d4/0xc00\n\
  \t ? put_event+0x30/0x30\n\t ? fsnotify+0xd2d/0xea0\n\t ? sched_clock_cpu+0x18/0x1a0\n\
  \t ? __fsnotify_update_child_dentry_flags.part.0+0x1b0/0x1b0\n\t ? pvclock_clocksource_read+0x152/0x2b0\n\
  \t ? pvclock_read_flags+0x80/0x80\n\t ? kvm_sched_clock_read+0x1a/0x30\n\t ? sched_clock_cpu+0x18/0x1a0\n\
  \t ? pvclock_clocksource_read+0x152/0x2b0\n\t ? locks_remove_file+0xec/0x470\n\t\
  \ ? pvclock_read_flags+0x80/0x80\n\t ? fcntl_setlk+0x880/0x880\n\t ? ima_file_free+0x8d/0x390\n\
  \t ? lockdep_rcu_suspicious+0x100/0x100\n\t ? ima_file_check+0x110/0x110\n\t ? fsnotify+0xea0/0xea0\n\
  \t ? kvm_sched_clock_read+0x1a/0x30\n\t ? rcu_note_context_switch+0x600/0x600\n\t\
  \ perf_release+0x21/0x40\n\t __fput+0x264/0x620\n\t ? fput+0xf0/0xf0\n\t ? do_raw_spin_unlock+0x121/0x210\n\
  \t ? do_raw_spin_trylock+0x150/0x150\n\t ? SyS_fchdir+0x100/0x100\n\t ? fsnotify+0xea0/0xea0\n\
  \t task_work_run+0x14b/0x1e0\n\t ? task_work_cancel+0x1c0/0x1c0\n\t ? copy_fd_bitmaps+0x150/0x150\n\
  \t ? vfs_read+0xe5/0x260\n\t exit_to_usermode_loop+0x17b/0x1b0\n\t ? trace_event_raw_event_sys_exit+0x1a0/0x1a0\n\
  \t do_syscall_64+0x3f6/0x490\n\t ? syscall_return_slowpath+0x2c0/0x2c0\n\t ? lockdep_sys_exit+0x1f/0xaa\n\
  \t ? syscall_return_slowpath+0x1a3/0x2c0\n\t ? lockdep_sys_exit+0x1f/0xaa\n\t ?\
  \ prepare_exit_to_usermode+0x11c/0x1e0\n\t ? enter_from_user_mode+0x30/0x30\n\t\
  random: crng init done\n\t ? __put_user_4+0x1c/0x30\n\t entry_SYSCALL_64_after_hwframe+0x3d/0xa2\n\
  \tRIP: 0033:0x7f41d95f9340\n\tRSP: 002b:00007fffe71e4268 EFLAGS: 00000246 ORIG_RAX:\
  \ 0000000000000003\n\tRAX: 0000000000000000 RBX: 000000000000000d RCX: 00007f41d95f9340\n\
  \tRDX: 0000000000000000 RSI: 0000000000002401 RDI: 000000000000000d\n\tRBP: 0000000000000000\
  \ R08: 00007f41ca8ff700 R09: 00007f41d996dd1f\n\tR10: 00007fffe71e41e0 R11: 0000000000000246\
  \ R12: 00007fffe71e4330\n\tR13: 0000000000000000 R14: fffffffffffffffc R15: 00007fffe71e4290\n\
  \n\tAllocated by task 870:\n\t kasan_kmalloc+0xa0/0xd0\n\t kmem_cache_alloc_node+0x11a/0x430\n\
  \t copy_process.part.19+0x11a0/0x41c0\n\t _do_fork+0x1be/0xa20\n\t do_syscall_64+0x198/0x490\n\
  \t entry_SYSCALL_64_after_hwframe+0x3d/0xa2\n\n\tFreed by task 0:\n\t __kasan_slab_free+0x12e/0x180\n\
  \t kmem_cache_free+0x102/0x4d0\n\t free_task+0xfe/0x160\n\t __put_task_struct+0x189/0x290\n\
  \t delayed_put_task_struct+0x119/0x250\n\t rcu_process_callbacks+0xa6c/0x1b60\n\t\
  \ __do_softirq+0x238/0x7ae\n\n\tThe buggy address belongs to the object at ffff880384f9b480\n\
  \t which belongs to the cache task_struct of size 12928\n\nIt occurs because task_struct\
  \ is freed before perf_event which refers\nto the task and task flags are checked\
  \ while teardown of the event.\nperf_event_alloc() assigns task_struct to hw.target\
  \ of perf_event,\nbut there is no reference counting for it.\n\nAs a fix we get_task_struct()\
  \ in perf_event_alloc() at above mentioned\nassignment and put_task_struct() in\
  \ _free_event().\n\nSigned-off-by: Prashant Bhole <bhole_prashant_q7@lab.ntt.co.jp>\n\
  Reviewed-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: Peter Zijlstra (Intel) <peterz@infradead.org>\n\
  Cc: <stable@kernel.org>\nCc: Alexander Shishkin <alexander.shishkin@linux.intel.com>\n\
  Cc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Jiri Olsa <jolsa@redhat.com>\n\
  Cc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Namhyung Kim <namhyung@kernel.org>\n\
  Cc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\n\
  Fixes: 63b6da39bb38e8f1a1ef3180d32a39d6 (\"perf: Fix perf_event_exit_task() race\"\
  )\nLink: http://lkml.kernel.org/r/20180409100346.6416-1-bhole_prashant_q7@lab.ntt.co.jp\n\
  Signed-off-by: Ingo Molnar <mingo@kernel.org>\n"
submodule:
- kernel/events
hunk_count: 3
covered_count: 1
