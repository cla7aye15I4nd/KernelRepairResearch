id: 2ca247c2d60c7023de7f
bug_link: https://syzkaller.appspot.com/bug?extid=2ca247c2d60c7023de7f
title: 'KMSAN: uninit-value in ath9k_htc_rx_msg'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: f020d9570a04df0762a2ac5c50cf1d8c511c9164
fix_commit: b383e8abed41cc6ff1a3b34de75df9397fa4878c
datetime: '2022-08-30T15:16:15+03:00'
fix_commit_message: 'wifi: ath9k: avoid uninit memory read in ath9k_htc_rx_msg()


  syzbot is reporting uninit value at ath9k_htc_rx_msg() [1], for

  ioctl(USB_RAW_IOCTL_EP_WRITE) can call ath9k_hif_usb_rx_stream() with

  pkt_len = 0 but ath9k_hif_usb_rx_stream() uses

  __dev_alloc_skb(pkt_len + 32, GFP_ATOMIC) based on an assumption that

  pkt_len is valid. As a result, ath9k_hif_usb_rx_stream() allocates skb

  with uninitialized memory and ath9k_htc_rx_msg() is reading from

  uninitialized memory.


  Since bytes accessed by ath9k_htc_rx_msg() is not known until

  ath9k_htc_rx_msg() is called, it would be difficult to check minimal valid

  pkt_len at "if (pkt_len > 2 * MAX_RX_BUF_SIZE) {" line in

  ath9k_hif_usb_rx_stream().


  We have two choices. One is to workaround by adding __GFP_ZERO so that

  ath9k_htc_rx_msg() sees 0 if pkt_len is invalid. The other is to let

  ath9k_htc_rx_msg() validate pkt_len before accessing. This patch chose

  the latter.


  Note that I''m not sure threshold condition is correct, for I can''t find

  details on possible packet length used by this protocol.


  Link: https://syzkaller.appspot.com/bug?extid=2ca247c2d60c7023de7f [1]

  Reported-by: syzbot <syzbot+2ca247c2d60c7023de7f@syzkaller.appspotmail.com>

  Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>

  Acked-by: Toke Høiland-Jørgensen <toke@toke.dk>

  Signed-off-by: Kalle Valo <quic_kvalo@quicinc.com>

  Link: https://lore.kernel.org/r/7acfa1be-4b5c-b2ce-de43-95b0593fb3e5@I-love.SAKURA.ne.jp

  '
submodule:
- drivers/net/wireless/ath/ath9k
hunk_count: 3
covered_count: 3
