loop0: detected capacity change from 0 to 4096
ntfs: volume version 3.1.
======================================================
WARNING: possible circular locking dependency detected
6.4.0-rc7-syzkaller-00204-g61dabacdad4e #0 Not tainted
------------------------------------------------------
syz-executor251/4997 is trying to acquire lock:
ffff88807637aad0 (&lcnbmp_mrec_lock_key){+.+.}-{3:3}, at: map_mft_record+0x4c/0x630 fs/ntfs/mft.c:154

but task is already holding lock:
ffff88802cb901f8 (&vol->lcnbmp_lock){+.+.}-{3:3}, at: ntfs_put_super+0x370/0xf80 fs/ntfs/super.c:2290

which lock already depends on the new lock.


the existing dependency chain (in reverse order) is:

-> #1 (&vol->lcnbmp_lock){+.+.}-{3:3}:
       lock_acquire+0x1e3/0x520 kernel/locking/lockdep.c:5705
       down_write+0x3a/0x50 kernel/locking/rwsem.c:1573
       __ntfs_cluster_free+0xdc/0x860 fs/ntfs/lcnalloc.c:862
       ntfs_cluster_free fs/ntfs/lcnalloc.h:96 [inline]
       ntfs_truncate+0x1257/0x2870 fs/ntfs/inode.c:2695
       ntfs_truncate_vfs fs/ntfs/inode.c:2862 [inline]
       ntfs_setattr+0x2cb/0x3b0 fs/ntfs/inode.c:2914
       notify_change+0xc8b/0xf40 fs/attr.c:483
       do_truncate+0x220/0x300 fs/open.c:66
       handle_truncate fs/namei.c:3295 [inline]
       do_open fs/namei.c:3640 [inline]
       path_openat+0x294e/0x3170 fs/namei.c:3791
       do_file_open_root+0x376/0x7c0 fs/namei.c:3843
       file_open_root+0x247/0x2a0 fs/open.c:1336
       do_handle_open+0x582/0x960 fs/fhandle.c:232
       do_syscall_x64 arch/x86/entry/common.c:50 [inline]
       do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80
       entry_SYSCALL_64_after_hwframe+0x63/0xcd

-> #0 (&lcnbmp_mrec_lock_key){+.+.}-{3:3}:
       check_prev_add kernel/locking/lockdep.c:3113 [inline]
       check_prevs_add kernel/locking/lockdep.c:3232 [inline]
       validate_chain+0x166b/0x58f0 kernel/locking/lockdep.c:3847
       __lock_acquire+0x1316/0x2070 kernel/locking/lockdep.c:5088
       lock_acquire+0x1e3/0x520 kernel/locking/lockdep.c:5705
       __mutex_lock_common+0x1d8/0x2530 kernel/locking/mutex.c:603
       __mutex_lock kernel/locking/mutex.c:747 [inline]
       mutex_lock_nested+0x1b/0x20 kernel/locking/mutex.c:799
       map_mft_record+0x4c/0x630 fs/ntfs/mft.c:154
       __ntfs_write_inode+0x81/0xbb0 fs/ntfs/inode.c:2978
       ntfs_commit_inode fs/ntfs/inode.h:300 [inline]
       ntfs_put_super+0x3bf/0xf80 fs/ntfs/super.c:2291
       generic_shutdown_super+0x134/0x340 fs/super.c:500
       kill_block_super+0x84/0xf0 fs/super.c:1407
       deactivate_locked_super+0xa4/0x110 fs/super.c:331
       cleanup_mnt+0x426/0x4c0 fs/namespace.c:1177
       task_work_run+0x24a/0x300 kernel/task_work.c:179
       exit_task_work include/linux/task_work.h:38 [inline]
       do_exit+0x68f/0x2290 kernel/exit.c:874
       do_group_exit+0x206/0x2c0 kernel/exit.c:1024
       __do_sys_exit_group kernel/exit.c:1035 [inline]
       __se_sys_exit_group kernel/exit.c:1033 [inline]
       __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1033
       do_syscall_x64 arch/x86/entry/common.c:50 [inline]
       do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80
       entry_SYSCALL_64_after_hwframe+0x63/0xcd

other info that might help us debug this:

 Possible unsafe locking scenario:

       CPU0                    CPU1
       ----                    ----
  lock(&vol->lcnbmp_lock);
                               lock(&lcnbmp_mrec_lock_key);
                               lock(&vol->lcnbmp_lock);
  lock(&lcnbmp_mrec_lock_key);

 *** DEADLOCK ***

2 locks held by syz-executor251/4997:
 #0: ffff88807e15c0e0 (&type->s_umount_key#47){+.+.}-{3:3}, at: deactivate_super+0xad/0xf0 fs/super.c:361
 #1: ffff88802cb901f8 (&vol->lcnbmp_lock){+.+.}-{3:3}, at: ntfs_put_super+0x370/0xf80 fs/ntfs/super.c:2290

stack backtrace:
CPU: 1 PID: 4997 Comm: syz-executor251 Not tainted 6.4.0-rc7-syzkaller-00204-g61dabacdad4e #0
Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 05/27/2023
Call Trace:
 <TASK>
 __dump_stack lib/dump_stack.c:88 [inline]
 dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106
 check_noncircular+0x2fe/0x3b0 kernel/locking/lockdep.c:2188
 check_prev_add kernel/locking/lockdep.c:3113 [inline]
 check_prevs_add kernel/locking/lockdep.c:3232 [inline]
 validate_chain+0x166b/0x58f0 kernel/locking/lockdep.c:3847
 __lock_acquire+0x1316/0x2070 kernel/locking/lockdep.c:5088
 lock_acquire+0x1e3/0x520 kernel/locking/lockdep.c:5705
 __mutex_lock_common+0x1d8/0x2530 kernel/locking/mutex.c:603
 __mutex_lock kernel/locking/mutex.c:747 [inline]
 mutex_lock_nested+0x1b/0x20 kernel/locking/mutex.c:799
 map_mft_record+0x4c/0x630 fs/ntfs/mft.c:154
 __ntfs_write_inode+0x81/0xbb0 fs/ntfs/inode.c:2978
 ntfs_commit_inode fs/ntfs/inode.h:300 [inline]
 ntfs_put_super+0x3bf/0xf80 fs/ntfs/super.c:2291
 generic_shutdown_super+0x134/0x340 fs/super.c:500
 kill_block_super+0x84/0xf0 fs/super.c:1407
 deactivate_locked_super+0xa4/0x110 fs/super.c:331
 cleanup_mnt+0x426/0x4c0 fs/namespace.c:1177
 task_work_run+0x24a/0x300 kernel/task_work.c:179
 exit_task_work include/linux/task_work.h:38 [inline]
 do_exit+0x68f/0x2290 kernel/exit.c:874
 do_group_exit+0x206/0x2c0 kernel/exit.c:1024
 __do_sys_exit_group kernel/exit.c:1035 [inline]
 __se_sys_exit_group kernel/exit.c:1033 [inline]
 __x64_sys_exit_group+0x3f/0x40 kernel/exit.c:1033
 do_syscall_x64 arch/x86/entry/common.c:50 [inline]
 do_syscall_64+0x41/0xc0 arch/x86/entry/common.c:80
 entry_SYSCALL_64_after_hwframe+0x63/0xcd
RIP: 0033:0x7f7e2260aa29
Code: Unable to access opcode bytes at 0x7f7e2260a9ff.
RSP: 002b:00007fff1e99bff8 EFLAGS: 00000246 ORIG_RAX: 00000000000000e7
RAX: ffffffffffffffda RBX: 00007f7e2269f330 RCX: 00007f7e2260aa29
RDX: 000000000000003c RSI: 00000000000000e7 RDI: 0000000000000001
