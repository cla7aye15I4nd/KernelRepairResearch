id: dc7c3ca638e773db07f6
bug_link: https://syzkaller.appspot.com/bug?extid=dc7c3ca638e773db07f6
title: 'KASAN: use-after-free Read in driver_register'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 4031cd95cba70c72e4cadc2d46624bcd31e5a6c0
fix_commit: 5f0b5f4d50fa0faa8c76ef9d42a42e8d43f98b44
datetime: '2022-05-12T18:34:58+02:00'
fix_commit_message: "usb: gadget: fix race when gadget driver register via ioctl\n\
  \nThe usb_gadget_register_driver can be called multi time by to\nthreads via USB_RAW_IOCTL_RUN\
  \ ioctl syscall, which will lead\nto multiple registrations.\n\nCall trace:\n  driver_register+0x220/0x3a0\
  \ drivers/base/driver.c:171\n  usb_gadget_register_driver_owner+0xfb/0x1e0\n   \
  \ drivers/usb/gadget/udc/core.c:1546\n  raw_ioctl_run drivers/usb/gadget/legacy/raw_gadget.c:513\
  \ [inline]\n  raw_ioctl+0x1883/0x2730 drivers/usb/gadget/legacy/raw_gadget.c:1220\n\
  \  ioctl USB_RAW_IOCTL_RUN\n\nThis routine allows two processes to register the\
  \ same driver instance\nvia ioctl syscall. which lead to a race condition.\n\nPlease\
  \ refer to the following scenarios.\n\n           T1                           \
  \       T2\n------------------------------------------------------------------\n\
  usb_gadget_register_driver_owner\n  driver_register                    driver_register\n\
  \    driver_find                       driver_find\n    bus_add_driver         \
  \           bus_add_driver\n      priv alloced                     <context switch>\n\
  \      drv->p = priv;\n      <schedule out>\n      kobject_init_and_add // refcount\
  \ = 1;\n   //couldn't find an available UDC or it's busy\n   <context switch>\n\
  \                                       priv alloced\n                         \
  \              drv->priv = priv;\n                                       kobject_init_and_add\n\
  \                                         ---> refcount = 1 <------\n          \
  \                             // register success\n                            \
  \           <context switch>\n===================== another ioctl/process ======================\n\
  \                                      driver_register\n                       \
  \                driver_find\n                                        k = kset_find_obj()\n\
  \                                         ---> refcount = 2 <------\n          \
  \                              <context out>\n   driver_unregister\n   // drv->p\
  \ become T2's priv\n   ---> refcount = 1 <------\n   <context switch>\n        \
  \                                kobject_put(k)\n                              \
  \           ---> refcount = 0 <------\n                                        return\
  \ priv->driver;\n                                        --------UAF here----------\n\
  \nThere will be UAF in this scenario.\n\nWe can fix it by adding a new STATE_DEV_REGISTERING\
  \ device state to\navoid double register.\n\nReported-by: syzbot+dc7c3ca638e773db07f6@syzkaller.appspotmail.com\n\
  Link: https://lore.kernel.org/all/000000000000e66c2805de55b15a@google.com/\nReviewed-by:\
  \ Andrey Konovalov <andreyknvl@gmail.com>\nSigned-off-by: Schspa Shi <schspa@gmail.com>\n\
  Link: https://lore.kernel.org/r/20220508150247.38204-1-schspa@gmail.com\nSigned-off-by:\
  \ Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n"
submodule:
- drivers/usb/gadget/legacy
hunk_count: 2
covered_count: 2
