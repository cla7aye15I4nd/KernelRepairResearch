id: fa379358c28cc87cc307
bug_link: https://syzkaller.appspot.com/bug?extid=fa379358c28cc87cc307
title: possible deadlock in __unix_gc
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: e3eb7dd47bd4806f00e104eb6da092c435f9fb21
fix_commit: 1971d13ffa84a551d29a81fdf5b5ec5be166ac83
datetime: '2024-04-25T08:37:02-07:00'
fix_commit_message: "af_unix: Suppress false-positive lockdep splat for spin_lock()\
  \ in __unix_gc().\n\nsyzbot reported a lockdep splat regarding unix_gc_lock and\n\
  unix_state_lock().\n\nOne is called from recvmsg() for a connected socket, and another\n\
  is called from GC for TCP_LISTEN socket.\n\nSo, the splat is false-positive.\n\n\
  Let's add a dedicated lock class for the latter to suppress the splat.\n\nNote that\
  \ this change is not necessary for net-next.git as the issue\nis only applied to\
  \ the old GC impl.\n\n[0]:\nWARNING: possible circular locking dependency detected\n\
  6.9.0-rc5-syzkaller-00007-g4d2008430ce8 #0 Not tainted\n -----------------------------------------------------\n\
  kworker/u8:1/11 is trying to acquire lock:\nffff88807cea4e70 (&u->lock){+.+.}-{2:2},\
  \ at: spin_lock include/linux/spinlock.h:351 [inline]\nffff88807cea4e70 (&u->lock){+.+.}-{2:2},\
  \ at: __unix_gc+0x40e/0xf70 net/unix/garbage.c:302\n\nbut task is already holding\
  \ lock:\nffffffff8f6ab638 (unix_gc_lock){+.+.}-{2:2}, at: spin_lock include/linux/spinlock.h:351\
  \ [inline]\nffffffff8f6ab638 (unix_gc_lock){+.+.}-{2:2}, at: __unix_gc+0x117/0xf70\
  \ net/unix/garbage.c:261\n\nwhich lock already depends on the new lock.\n\nthe existing\
  \ dependency chain (in reverse order) is:\n\n -> #1 (unix_gc_lock){+.+.}-{2:2}:\n\
  \       lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5754\n       __raw_spin_lock\
  \ include/linux/spinlock_api_smp.h:133 [inline]\n       _raw_spin_lock+0x2e/0x40\
  \ kernel/locking/spinlock.c:154\n       spin_lock include/linux/spinlock.h:351 [inline]\n\
  \       unix_notinflight+0x13d/0x390 net/unix/garbage.c:140\n       unix_detach_fds\
  \ net/unix/af_unix.c:1819 [inline]\n       unix_destruct_scm+0x221/0x350 net/unix/af_unix.c:1876\n\
  \       skb_release_head_state+0x100/0x250 net/core/skbuff.c:1188\n       skb_release_all\
  \ net/core/skbuff.c:1200 [inline]\n       __kfree_skb net/core/skbuff.c:1216 [inline]\n\
  \       kfree_skb_reason+0x16d/0x3b0 net/core/skbuff.c:1252\n       kfree_skb include/linux/skbuff.h:1262\
  \ [inline]\n       manage_oob net/unix/af_unix.c:2672 [inline]\n       unix_stream_read_generic+0x1125/0x2700\
  \ net/unix/af_unix.c:2749\n       unix_stream_splice_read+0x239/0x320 net/unix/af_unix.c:2981\n\
  \       do_splice_read fs/splice.c:985 [inline]\n       splice_file_to_pipe+0x299/0x500\
  \ fs/splice.c:1295\n       do_splice+0xf2d/0x1880 fs/splice.c:1379\n       __do_splice\
  \ fs/splice.c:1436 [inline]\n       __do_sys_splice fs/splice.c:1652 [inline]\n\
  \       __se_sys_splice+0x331/0x4a0 fs/splice.c:1634\n       do_syscall_x64 arch/x86/entry/common.c:52\
  \ [inline]\n       do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\
  \n -> #0 (&u->lock){+.+.}-{2:2}:\n       check_prev_add kernel/locking/lockdep.c:3134\
  \ [inline]\n       check_prevs_add kernel/locking/lockdep.c:3253 [inline]\n    \
  \   validate_chain+0x18cb/0x58e0 kernel/locking/lockdep.c:3869\n       __lock_acquire+0x1346/0x1fd0\
  \ kernel/locking/lockdep.c:5137\n       lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5754\n\
  \       __raw_spin_lock include/linux/spinlock_api_smp.h:133 [inline]\n       _raw_spin_lock+0x2e/0x40\
  \ kernel/locking/spinlock.c:154\n       spin_lock include/linux/spinlock.h:351 [inline]\n\
  \       __unix_gc+0x40e/0xf70 net/unix/garbage.c:302\n       process_one_work kernel/workqueue.c:3254\
  \ [inline]\n       process_scheduled_works+0xa10/0x17c0 kernel/workqueue.c:3335\n\
  \       worker_thread+0x86d/0xd70 kernel/workqueue.c:3416\n       kthread+0x2f0/0x390\
  \ kernel/kthread.c:388\n       ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n\
  \       ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\nother info\
  \ that might help us debug this:\n\n Possible unsafe locking scenario:\n\n     \
  \  CPU0                    CPU1\n       ----                    ----\n  lock(unix_gc_lock);\n\
  \                               lock(&u->lock);\n                              \
  \ lock(unix_gc_lock);\n  lock(&u->lock);\n\n *** DEADLOCK ***\n\n3 locks held by\
  \ kworker/u8:1/11:\n #0: ffff888015089148 ((wq_completion)events_unbound){+.+.}-{0:0},\
  \ at: process_one_work kernel/workqueue.c:3229 [inline]\n #0: ffff888015089148 ((wq_completion)events_unbound){+.+.}-{0:0},\
  \ at: process_scheduled_works+0x8e0/0x17c0 kernel/workqueue.c:3335\n #1: ffffc90000107d00\
  \ (unix_gc_work){+.+.}-{0:0}, at: process_one_work kernel/workqueue.c:3230 [inline]\n\
  \ #1: ffffc90000107d00 (unix_gc_work){+.+.}-{0:0}, at: process_scheduled_works+0x91b/0x17c0\
  \ kernel/workqueue.c:3335\n #2: ffffffff8f6ab638 (unix_gc_lock){+.+.}-{2:2}, at:\
  \ spin_lock include/linux/spinlock.h:351 [inline]\n #2: ffffffff8f6ab638 (unix_gc_lock){+.+.}-{2:2},\
  \ at: __unix_gc+0x117/0xf70 net/unix/garbage.c:261\n\nstack backtrace:\nCPU: 0 PID:\
  \ 11 Comm: kworker/u8:1 Not tainted 6.9.0-rc5-syzkaller-00007-g4d2008430ce8 #0\n\
  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\n\
  Workqueue: events_unbound __unix_gc\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88\
  \ [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\n check_noncircular+0x36a/0x4a0\
  \ kernel/locking/lockdep.c:2187\n check_prev_add kernel/locking/lockdep.c:3134 [inline]\n\
  \ check_prevs_add kernel/locking/lockdep.c:3253 [inline]\n validate_chain+0x18cb/0x58e0\
  \ kernel/locking/lockdep.c:3869\n __lock_acquire+0x1346/0x1fd0 kernel/locking/lockdep.c:5137\n\
  \ lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5754\n __raw_spin_lock include/linux/spinlock_api_smp.h:133\
  \ [inline]\n _raw_spin_lock+0x2e/0x40 kernel/locking/spinlock.c:154\n spin_lock\
  \ include/linux/spinlock.h:351 [inline]\n __unix_gc+0x40e/0xf70 net/unix/garbage.c:302\n\
  \ process_one_work kernel/workqueue.c:3254 [inline]\n process_scheduled_works+0xa10/0x17c0\
  \ kernel/workqueue.c:3335\n worker_thread+0x86d/0xd70 kernel/workqueue.c:3416\n\
  \ kthread+0x2f0/0x390 kernel/kthread.c:388\n ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n\
  \ ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n </TASK>\n\nFixes:\
  \ 47d8ac011fe1 (\"af_unix: Fix garbage collector racing against connect()\")\nReported-and-tested-by:\
  \ syzbot+fa379358c28cc87cc307@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=fa379358c28cc87cc307\n\
  Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>\nLink: https://lore.kernel.org/r/20240424170443.9832-1-kuniyu@amazon.com\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n"
submodule:
- include/net
- net/unix
hunk_count: 2
covered_count: 1
