id: d31adfb277377ef8fcba
bug_link: https://syzkaller.appspot.com/bug?extid=d31adfb277377ef8fcba
title: 'KASAN: slab-use-after-free Read in iommufd_vfio_ioas'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: bd7a282650b8beb57bc9d19bfcb714b1ccae843a
fix_commit: 6f9c4d8c468c189d6dc470324bd52955f8aa0a10
datetime: '2023-11-29T20:30:03-04:00'
fix_commit_message: "iommufd: Do not UAF during iommufd_put_object()\n\nThe mixture\
  \ of kernel and user space lifecycle objects continues to be\ncomplicated inside\
  \ iommufd. The obj->destroy_rwsem is used to bring order\nto the kernel driver destruction\
  \ sequence but it cannot be sequenced right\nwith the other refcounts so we end\
  \ up possibly UAF'ing:\n\n  BUG: KASAN: slab-use-after-free in __up_read+0x627/0x750\
  \ kernel/locking/rwsem.c:1342\n  Read of size 8 at addr ffff888073cde868 by task\
  \ syz-executor934/6535\n\n  CPU: 1 PID: 6535 Comm: syz-executor934 Not tainted 6.6.0-rc7-syzkaller-00195-g2af9b20dbb39\
  \ #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS\
  \ Google 10/09/2023\n  Call Trace:\n   <TASK>\n   __dump_stack lib/dump_stack.c:88\
  \ [inline]\n   dump_stack_lvl+0xd9/0x1b0 lib/dump_stack.c:106\n   print_address_description\
  \ mm/kasan/report.c:364 [inline]\n   print_report+0xc4/0x620 mm/kasan/report.c:475\n\
  \   kasan_report+0xda/0x110 mm/kasan/report.c:588\n   __up_read+0x627/0x750 kernel/locking/rwsem.c:1342\n\
  \   iommufd_put_object drivers/iommu/iommufd/iommufd_private.h:149 [inline]\n  \
  \ iommufd_vfio_ioas+0x46c/0x580 drivers/iommu/iommufd/vfio_compat.c:146\n   iommufd_fops_ioctl+0x347/0x4d0\
  \ drivers/iommu/iommufd/main.c:398\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl\
  \ fs/ioctl.c:871 [inline]\n   __se_sys_ioctl fs/ioctl.c:857 [inline]\n   __x64_sys_ioctl+0x18f/0x210\
  \ fs/ioctl.c:857\n   do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n   do_syscall_64+0x38/0xb0\
  \ arch/x86/entry/common.c:80\n   entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nThere\
  \ are two races here, the more obvious one:\n\n     CPU 0                      \
  \           CPU 1\n iommufd_put_object()\n                                     \
  \     iommufd_destroy()\n  refcount_dec(&obj->users)\n\n \t                    \
  \               iommufd_object_remove()\n\t\t\t\t\t   kfree()\n  up_read(&obj->destroy_rwsem)\
  \ // Boom\n\nAnd there is also perhaps some possibility that the rwsem could hit\
  \ an\nissue:\n\n     CPU 0                                 CPU 1\n iommufd_put_object()\n\
  \                                         iommufd_object_destroy_user()\n  refcount_dec(&obj->users);\n\
  \ \t                                  down_write(&obj->destroy_rwsem)\n  up_read(&obj->destroy_rwsem);\n\
  \                                             atomic_long_or(RWSEM_FLAG_WAITERS,\
  \ &sem->count);\n      tmp = atomic_long_add_return_release()\n                \
  \                             rwsem_try_write_lock()\n \t                      \
  \            iommufd_object_remove()\n\t                                  up_write(&obj->destroy_rwsem)\n\
  \t\t\t\t\t  kfree()\n      clear_nonspinnable() // Boom\n\nFix this by reorganizing\
  \ this again so that two refcounts are used to keep\ntrack of things with a rule\
  \ that users == 0 && shortterm_users == 0 means\nno other threads have that memory.\
  \ Put a wait_queue in the iommufd_ctx\nobject that is triggered when any sub object\
  \ reaches a 0\nshortterm_users. This allows the same wait for userspace ioctls to\
  \ finish\nbehavior that the rwsem was providing.\n\nThis is weaker still than the\
  \ prior versions:\n\n - There is no bias on shortterm_users so if some thread is\
  \ waiting to\n   destroy other threads can continue to get new read sides\n\n -\
  \ If destruction fails, eg because of an active in-kernel user, then\n   shortterm_users\
  \ will have cycled to zero momentarily blocking new users\n\n - If userspace races\
  \ destroy with other userspace operations they\n   continue to get an EBUSY since\
  \ we still can't intermix looking up an ID\n   and sleeping for its unref\n\nIn\
  \ all cases these are things that userspace brings on itself, correct\nprograms\
  \ will not hit them.\n\nFixes: 99f98a7c0d69 (\"iommufd: IOMMUFD_DESTROY should not\
  \ increase the refcount\")\nLink: https://lore.kernel.org/all/2-v2-ca9e00171c5b+123-iommufd_syz4_jgg@nvidia.com/\n\
  Reported-by: syzbot+d31adfb277377ef8fcba@syzkaller.appspotmail.com\nCloses: https://lore.kernel.org/r/00000000000055ef9a0609336580@google.com\n\
  Reviewed-by: Kevin Tian <kevin.tian@intel.com>\nSigned-off-by: Jason Gunthorpe <jgg@nvidia.com>\n"
submodule:
- drivers/iommu/iommufd
hunk_count: 10
covered_count: 9
