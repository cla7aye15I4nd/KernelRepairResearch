id: 4704b3cc972bd76024f1
bug_link: https://syzkaller.appspot.com/bug?extid=4704b3cc972bd76024f1
title: kernel BUG in btrfs_get_ordered_extents_for_logging
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: b1934cd6069538db2255dc94ba573771ecf3b560
fix_commit: cd9253c23aedd61eb5ff11f37a36247cd46faf86
datetime: '2024-09-03T20:29:55+02:00'
fix_commit_message: "btrfs: fix race between direct IO write and fsync when using\
  \ same fd\n\nIf we have 2 threads that are using the same file descriptor and one\
  \ of\nthem is doing direct IO writes while the other is doing fsync, we have a\n\
  race where we can end up either:\n\n1) Attempt a fsync without holding the inode's\
  \ lock, triggering an\n   assertion failures when assertions are enabled;\n\n2)\
  \ Do an invalid memory access from the fsync task because the file private\n   points\
  \ to memory allocated on stack by the direct IO task and it may be\n   used by the\
  \ fsync task after the stack was destroyed.\n\nThe race happens like this:\n\n1)\
  \ A user space program opens a file descriptor with O_DIRECT;\n\n2) The program\
  \ spawns 2 threads using libpthread for example;\n\n3) One of the threads uses the\
  \ file descriptor to do direct IO writes,\n   while the other calls fsync using\
  \ the same file descriptor.\n\n4) Call task A the thread doing direct IO writes\
  \ and task B the thread\n   doing fsyncs;\n\n5) Task A does a direct IO write, and\
  \ at btrfs_direct_write() sets the\n   file's private to an on stack allocated private\
  \ with the member\n   'fsync_skip_inode_lock' set to true;\n\n6) Task B enters btrfs_sync_file()\
  \ and sees that there's a private\n   structure associated to the file which has\
  \ 'fsync_skip_inode_lock' set\n   to true, so it skips locking the inode's VFS lock;\n\
  \n7) Task A completes the direct IO write, and resets the file's private to\n  \
  \ NULL since it had no prior private and our private was stack allocated.\n   Then\
  \ it unlocks the inode's VFS lock;\n\n8) Task B enters btrfs_get_ordered_extents_for_logging(),\
  \ then the\n   assertion that checks the inode's VFS lock is held fails, since task\
  \ B\n   never locked it and task A has already unlocked it.\n\nThe stack trace produced\
  \ is the following:\n\n   assertion failed: inode_is_locked(&inode->vfs_inode),\
  \ in fs/btrfs/ordered-data.c:983\n   ------------[ cut here ]------------\n   kernel\
  \ BUG at fs/btrfs/ordered-data.c:983!\n   Oops: invalid opcode: 0000 [#1] PREEMPT\
  \ SMP PTI\n   CPU: 9 PID: 5072 Comm: worker Tainted: G     U     OE      6.10.5-1-default\
  \ #1 openSUSE Tumbleweed 69f48d427608e1c09e60ea24c6c55e2ca1b049e8\n   Hardware name:\
  \ Acer Predator PH315-52/Covini_CFS, BIOS V1.12 07/28/2020\n   RIP: 0010:btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42\
  \ [btrfs]\n   Code: 50 d6 86 c0 e8 (...)\n   RSP: 0018:ffff9e4a03dcfc78 EFLAGS:\
  \ 00010246\n   RAX: 0000000000000054 RBX: ffff9078a9868e98 RCX: 0000000000000000\n\
  \   RDX: 0000000000000000 RSI: ffff907dce4a7800 RDI: ffff907dce4a7800\n   RBP: ffff907805518800\
  \ R08: 0000000000000000 R09: ffff9e4a03dcfb38\n   R10: ffff9e4a03dcfb30 R11: 0000000000000003\
  \ R12: ffff907684ae7800\n   R13: 0000000000000001 R14: ffff90774646b600 R15: 0000000000000000\n\
  \   FS:  00007f04b96006c0(0000) GS:ffff907dce480000(0000) knlGS:0000000000000000\n\
  \   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n   CR2: 00007f32acbfc000\
  \ CR3: 00000001fd4fa005 CR4: 00000000003726f0\n   Call Trace:\n    <TASK>\n    ?\
  \ __die_body.cold+0x14/0x24\n    ? die+0x2e/0x50\n    ? do_trap+0xca/0x110\n   \
  \ ? do_error_trap+0x6a/0x90\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42\
  \ [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? exc_invalid_op+0x50/0x70\n\
  \    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42 [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n\
  \    ? asm_exc_invalid_op+0x1a/0x20\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42\
  \ [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? btrfs_get_ordered_extents_for_logging.cold+0x1f/0x42\
  \ [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    btrfs_sync_file+0x21a/0x4d0\
  \ [btrfs bb26272d49b4cdc847cf3f7faadd459b62caee9a]\n    ? __seccomp_filter+0x31d/0x4f0\n\
  \    __x64_sys_fdatasync+0x4f/0x90\n    do_syscall_64+0x82/0x160\n    ? do_futex+0xcb/0x190\n\
  \    ? __x64_sys_futex+0x10e/0x1d0\n    ? switch_fpu_return+0x4f/0xd0\n    ? syscall_exit_to_user_mode+0x72/0x220\n\
  \    ? do_syscall_64+0x8e/0x160\n    ? syscall_exit_to_user_mode+0x72/0x220\n  \
  \  ? do_syscall_64+0x8e/0x160\n    ? syscall_exit_to_user_mode+0x72/0x220\n    ?\
  \ do_syscall_64+0x8e/0x160\n    ? syscall_exit_to_user_mode+0x72/0x220\n    ? do_syscall_64+0x8e/0x160\n\
  \    entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nAnother problem here is if task\
  \ B grabs the private pointer and then uses\nit after task A has finished, since\
  \ the private was allocated in the stack\nof task A, it results in some invalid\
  \ memory access with a hard to predict\nresult.\n\nThis issue, triggering the assertion,\
  \ was observed with QEMU workloads by\ntwo users in the Link tags below.\n\nFix\
  \ this by not relying on a file's private to pass information to fsync\nthat it\
  \ should skip locking the inode and instead pass this information\nthrough a special\
  \ value stored in current->journal_info. This is safe\nbecause in the relevant section\
  \ of the direct IO write path we are not\nholding a transaction handle, so current->journal_info\
  \ is NULL.\n\nThe following C program triggers the issue:\n\n   $ cat repro.c\n\
  \   /* Get the O_DIRECT definition. */\n   #ifndef _GNU_SOURCE\n   #define _GNU_SOURCE\n\
  \   #endif\n\n   #include <stdio.h>\n   #include <stdlib.h>\n   #include <unistd.h>\n\
  \   #include <stdint.h>\n   #include <fcntl.h>\n   #include <errno.h>\n   #include\
  \ <string.h>\n   #include <pthread.h>\n\n   static int fd;\n\n   static ssize_t\
  \ do_write(int fd, const void *buf, size_t count, off_t offset)\n   {\n       while\
  \ (count > 0) {\n           ssize_t ret;\n\n           ret = pwrite(fd, buf, count,\
  \ offset);\n           if (ret < 0) {\n               if (errno == EINTR)\n    \
  \               continue;\n               return ret;\n           }\n          \
  \ count -= ret;\n           buf += ret;\n       }\n       return 0;\n   }\n\n  \
  \ static void *fsync_loop(void *arg)\n   {\n       while (1) {\n           int ret;\n\
  \n           ret = fsync(fd);\n           if (ret != 0) {\n               perror(\"\
  Fsync failed\");\n               exit(6);\n           }\n       }\n   }\n\n   int\
  \ main(int argc, char *argv[])\n   {\n       long pagesize;\n       void *write_buf;\n\
  \       pthread_t fsyncer;\n       int ret;\n\n       if (argc != 2) {\n       \
  \    fprintf(stderr, \"Use: %s <file path>\\n\", argv[0]);\n           return 1;\n\
  \       }\n\n       fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC | O_DIRECT,\
  \ 0666);\n       if (fd == -1) {\n           perror(\"Failed to open/create file\"\
  );\n           return 1;\n       }\n\n       pagesize = sysconf(_SC_PAGE_SIZE);\n\
  \       if (pagesize == -1) {\n           perror(\"Failed to get page size\");\n\
  \           return 2;\n       }\n\n       ret = posix_memalign(&write_buf, pagesize,\
  \ pagesize);\n       if (ret) {\n           perror(\"Failed to allocate buffer\"\
  );\n           return 3;\n       }\n\n       ret = pthread_create(&fsyncer, NULL,\
  \ fsync_loop, NULL);\n       if (ret != 0) {\n           fprintf(stderr, \"Failed\
  \ to create writer thread: %d\\n\", ret);\n           return 4;\n       }\n\n  \
  \     while (1) {\n           ret = do_write(fd, write_buf, pagesize, 0);\n    \
  \       if (ret != 0) {\n               perror(\"Write failed\");\n            \
  \   exit(5);\n           }\n       }\n\n       return 0;\n   }\n\n   $ mkfs.btrfs\
  \ -f /dev/sdi\n   $ mount /dev/sdi /mnt/sdi\n   $ timeout 10 ./repro /mnt/sdi/foo\n\
  \nUsually the race is triggered within less than 1 second. A test case for\nfstests\
  \ will follow soon.\n\nReported-by: Paulo Dias <paulo.miguel.dias@gmail.com>\nLink:\
  \ https://bugzilla.kernel.org/show_bug.cgi?id=219187\nReported-by: Andreas Jahn\
  \ <jahn-andi@web.de>\nLink: https://bugzilla.kernel.org/show_bug.cgi?id=219199\n\
  Reported-by: syzbot+4704b3cc972bd76024f1@syzkaller.appspotmail.com\nLink: https://lore.kernel.org/linux-btrfs/00000000000044ff540620d7dee2@google.com/\n\
  Fixes: 939b656bc8ab (\"btrfs: fix corruption after buffer fault in during direct\
  \ IO append write\")\nCC: stable@vger.kernel.org # 5.15+\nReviewed-by: Josef Bacik\
  \ <josef@toxicpanda.com>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nReviewed-by:\
  \ David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>\n"
submodule:
- fs/btrfs
hunk_count: 6
covered_count: 0
