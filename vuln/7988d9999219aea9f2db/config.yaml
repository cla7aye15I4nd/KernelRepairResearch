id: 7988d9999219aea9f2db
bug_link: https://syzkaller.appspot.com/bug?extid=7988d9999219aea9f2db
title: possible deadlock in f2fs_evict_inode
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 0c3a38a4b442893f8baca72e44a2a27d52d6cc75
fix_commit: f10a890308a7cd8794e21f646f09827c6cb4bf5d
datetime: '2024-11-01T01:24:41+00:00'
fix_commit_message: "f2fs: fix to avoid potential deadlock in f2fs_record_stop_reason()\n\
  \nsyzbot reports deadlock issue of f2fs as below:\n\n======================================================\n\
  WARNING: possible circular locking dependency detected\n6.12.0-rc3-syzkaller-00087-gc964ced77262\
  \ #0 Not tainted\n------------------------------------------------------\nkswapd0/79\
  \ is trying to acquire lock:\nffff888011824088 (&sbi->sb_lock){++++}-{3:3}, at:\
  \ f2fs_down_write fs/f2fs/f2fs.h:2199 [inline]\nffff888011824088 (&sbi->sb_lock){++++}-{3:3},\
  \ at: f2fs_record_stop_reason+0x52/0x1d0 fs/f2fs/super.c:4068\n\nbut task is already\
  \ holding lock:\nffff88804bd92610 (sb_internal#2){.+.+}-{0:0}, at: f2fs_evict_inode+0x662/0x15c0\
  \ fs/f2fs/inode.c:842\n\nwhich lock already depends on the new lock.\n\nthe existing\
  \ dependency chain (in reverse order) is:\n\n-> #2 (sb_internal#2){.+.+}-{0:0}:\n\
  \       lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825\n       percpu_down_read\
  \ include/linux/percpu-rwsem.h:51 [inline]\n       __sb_start_write include/linux/fs.h:1716\
  \ [inline]\n       sb_start_intwrite+0x4d/0x1c0 include/linux/fs.h:1899\n      \
  \ f2fs_evict_inode+0x662/0x15c0 fs/f2fs/inode.c:842\n       evict+0x4e8/0x9b0 fs/inode.c:725\n\
  \       f2fs_evict_inode+0x1a4/0x15c0 fs/f2fs/inode.c:807\n       evict+0x4e8/0x9b0\
  \ fs/inode.c:725\n       dispose_list fs/inode.c:774 [inline]\n       prune_icache_sb+0x239/0x2f0\
  \ fs/inode.c:963\n       super_cache_scan+0x38c/0x4b0 fs/super.c:223\n       do_shrink_slab+0x701/0x1160\
  \ mm/shrinker.c:435\n       shrink_slab+0x1093/0x14d0 mm/shrinker.c:662\n      \
  \ shrink_one+0x43b/0x850 mm/vmscan.c:4818\n       shrink_many mm/vmscan.c:4879 [inline]\n\
  \       lru_gen_shrink_node mm/vmscan.c:4957 [inline]\n       shrink_node+0x3799/0x3de0\
  \ mm/vmscan.c:5937\n       kswapd_shrink_node mm/vmscan.c:6765 [inline]\n      \
  \ balance_pgdat mm/vmscan.c:6957 [inline]\n       kswapd+0x1ca3/0x3700 mm/vmscan.c:7226\n\
  \       kthread+0x2f0/0x390 kernel/kthread.c:389\n       ret_from_fork+0x4b/0x80\
  \ arch/x86/kernel/process.c:147\n       ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\
  \n-> #1 (fs_reclaim){+.+.}-{0:0}:\n       lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825\n\
  \       __fs_reclaim_acquire mm/page_alloc.c:3834 [inline]\n       fs_reclaim_acquire+0x88/0x130\
  \ mm/page_alloc.c:3848\n       might_alloc include/linux/sched/mm.h:318 [inline]\n\
  \       prepare_alloc_pages+0x147/0x5b0 mm/page_alloc.c:4493\n       __alloc_pages_noprof+0x16f/0x710\
  \ mm/page_alloc.c:4722\n       alloc_pages_mpol_noprof+0x3e8/0x680 mm/mempolicy.c:2265\n\
  \       alloc_pages_noprof mm/mempolicy.c:2345 [inline]\n       folio_alloc_noprof+0x128/0x180\
  \ mm/mempolicy.c:2352\n       filemap_alloc_folio_noprof+0xdf/0x500 mm/filemap.c:1010\n\
  \       do_read_cache_folio+0x2eb/0x850 mm/filemap.c:3787\n       read_mapping_folio\
  \ include/linux/pagemap.h:1011 [inline]\n       f2fs_commit_super+0x3c0/0x7d0 fs/f2fs/super.c:4032\n\
  \       f2fs_record_stop_reason+0x13b/0x1d0 fs/f2fs/super.c:4079\n       f2fs_handle_critical_error+0x2ac/0x5c0\
  \ fs/f2fs/super.c:4174\n       f2fs_write_inode+0x35f/0x4d0 fs/f2fs/inode.c:785\n\
  \       write_inode fs/fs-writeback.c:1503 [inline]\n       __writeback_single_inode+0x711/0x10d0\
  \ fs/fs-writeback.c:1723\n       writeback_single_inode+0x1f3/0x660 fs/fs-writeback.c:1779\n\
  \       sync_inode_metadata+0xc4/0x120 fs/fs-writeback.c:2849\n       f2fs_release_file+0xa8/0x100\
  \ fs/f2fs/file.c:1941\n       __fput+0x23f/0x880 fs/file_table.c:431\n       task_work_run+0x24f/0x310\
  \ kernel/task_work.c:228\n       resume_user_mode_work include/linux/resume_user_mode.h:50\
  \ [inline]\n       exit_to_user_mode_loop kernel/entry/common.c:114 [inline]\n \
  \      exit_to_user_mode_prepare include/linux/entry-common.h:328 [inline]\n   \
  \    __syscall_exit_to_user_mode_work kernel/entry/common.c:207 [inline]\n     \
  \  syscall_exit_to_user_mode+0x168/0x370 kernel/entry/common.c:218\n       do_syscall_64+0x100/0x230\
  \ arch/x86/entry/common.c:89\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n\
  -> #0 (&sbi->sb_lock){++++}-{3:3}:\n       check_prev_add kernel/locking/lockdep.c:3161\
  \ [inline]\n       check_prevs_add kernel/locking/lockdep.c:3280 [inline]\n    \
  \   validate_chain+0x18ef/0x5920 kernel/locking/lockdep.c:3904\n       __lock_acquire+0x1384/0x2050\
  \ kernel/locking/lockdep.c:5202\n       lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825\n\
  \       down_write+0x99/0x220 kernel/locking/rwsem.c:1577\n       f2fs_down_write\
  \ fs/f2fs/f2fs.h:2199 [inline]\n       f2fs_record_stop_reason+0x52/0x1d0 fs/f2fs/super.c:4068\n\
  \       f2fs_handle_critical_error+0x2ac/0x5c0 fs/f2fs/super.c:4174\n       f2fs_evict_inode+0xa61/0x15c0\
  \ fs/f2fs/inode.c:883\n       evict+0x4e8/0x9b0 fs/inode.c:725\n       f2fs_evict_inode+0x1a4/0x15c0\
  \ fs/f2fs/inode.c:807\n       evict+0x4e8/0x9b0 fs/inode.c:725\n       dispose_list\
  \ fs/inode.c:774 [inline]\n       prune_icache_sb+0x239/0x2f0 fs/inode.c:963\n \
  \      super_cache_scan+0x38c/0x4b0 fs/super.c:223\n       do_shrink_slab+0x701/0x1160\
  \ mm/shrinker.c:435\n       shrink_slab+0x1093/0x14d0 mm/shrinker.c:662\n      \
  \ shrink_one+0x43b/0x850 mm/vmscan.c:4818\n       shrink_many mm/vmscan.c:4879 [inline]\n\
  \       lru_gen_shrink_node mm/vmscan.c:4957 [inline]\n       shrink_node+0x3799/0x3de0\
  \ mm/vmscan.c:5937\n       kswapd_shrink_node mm/vmscan.c:6765 [inline]\n      \
  \ balance_pgdat mm/vmscan.c:6957 [inline]\n       kswapd+0x1ca3/0x3700 mm/vmscan.c:7226\n\
  \       kthread+0x2f0/0x390 kernel/kthread.c:389\n       ret_from_fork+0x4b/0x80\
  \ arch/x86/kernel/process.c:147\n       ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\
  \nother info that might help us debug this:\n\nChain exists of:\n  &sbi->sb_lock\
  \ --> fs_reclaim --> sb_internal#2\n\n Possible unsafe locking scenario:\n\n   \
  \    CPU0                    CPU1\n       ----                    ----\n  rlock(sb_internal#2);\n\
  \                               lock(fs_reclaim);\n                            \
  \   lock(sb_internal#2);\n  lock(&sbi->sb_lock);\n\nRoot cause is there will be\
  \ potential deadlock in between\nbelow tasks:\n\nThread A\t\t\t\tKswapd\n- f2fs_ioc_commit_atomic_write\n\
  \ - mnt_want_write_file -- down_read lock A\n\t\t\t\t\t- balance_pgdat\n\t\t\t\t\
  \t - __fs_reclaim_acquire  -- lock B\n\t\t\t\t\t  - shrink_node\n\t\t\t\t\t   -\
  \ prune_icache_sb\n\t\t\t\t\t    - dispose_list\n\t\t\t\t\t     - f2fs_evict_inode\n\
  \t\t\t\t\t      - sb_start_intwrite  -- down_read lock A\n - f2fs_do_sync_file\n\
  \  - f2fs_write_inode\n   - f2fs_handle_critical_error\n    - f2fs_record_stop_reason\n\
  \     - f2fs_commit_super\n      - read_mapping_folio\n       - filemap_alloc_folio_noprof\n\
  \        - fs_reclaim_acquire  -- lock B\n\nBoth threads try to acquire read lock\
  \ of lock A, then its upcoming write\nlock grabber will trigger deadlock.\n\nLet's\
  \ always create an asynchronous task in f2fs_handle_critical_error()\nrather than\
  \ calling f2fs_record_stop_reason() synchronously to avoid\nthis potential deadlock\
  \ issue.\n\nFixes: b62e71be2110 (\"f2fs: support errors=remount-ro|continue|panic\
  \ mountoption\")\nReported-by: syzbot+be4a9983e95a5e25c8d3@syzkaller.appspotmail.com\n\
  Closes: https://lore.kernel.org/all/6704d667.050a0220.1e4d62.0081.GAE@google.com\n\
  Signed-off-by: Chao Yu <chao@kernel.org>\nReviewed-by: Daejun Park <daejun7.park@samsung.com>\n\
  Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>\n"
submodule:
- fs/f2fs
hunk_count: 4
covered_count: 2
