id: 223c7461c58c58a4cb10
bug_link: https://syzkaller.appspot.com/bug?extid=223c7461c58c58a4cb10
title: possible deadlock in tty_port_tty_get
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 659c0ce1cb9efc7f58d380ca4bb2a51ae9e30553
fix_commit: 1007843a91909a4995ee78a538f62d8665705b66
datetime: '2023-04-18T14:22:12-07:00'
fix_commit_message: "mm/page_alloc: fix potential deadlock on zonelist_update_seq\
  \ seqlock\n\nsyzbot is reporting circular locking dependency which involves\nzonelist_update_seq\
  \ seqlock [1], for this lock is checked by memory\nallocation requests which do\
  \ not need to be retried.\n\nOne deadlock scenario is kmalloc(GFP_ATOMIC) from an\
  \ interrupt handler.\n\n  CPU0\n  ----\n  __build_all_zonelists() {\n    write_seqlock(&zonelist_update_seq);\
  \ // makes zonelist_update_seq.seqcount odd\n    // e.g. timer interrupt handler\
  \ runs at this moment\n      some_timer_func() {\n        kmalloc(GFP_ATOMIC) {\n\
  \          __alloc_pages_slowpath() {\n            read_seqbegin(&zonelist_update_seq)\
  \ {\n              // spins forever because zonelist_update_seq.seqcount is odd\n\
  \            }\n          }\n        }\n      }\n    // e.g. timer interrupt handler\
  \ finishes\n    write_sequnlock(&zonelist_update_seq); // makes zonelist_update_seq.seqcount\
  \ even\n  }\n\nThis deadlock scenario can be easily eliminated by not calling\n\
  read_seqbegin(&zonelist_update_seq) from !__GFP_DIRECT_RECLAIM allocation\nrequests,\
  \ for retry is applicable to only __GFP_DIRECT_RECLAIM allocation\nrequests.  But\
  \ Michal Hocko does not know whether we should go with this\napproach.\n\nAnother\
  \ deadlock scenario which syzbot is reporting is a race between\nkmalloc(GFP_ATOMIC)\
  \ from tty_insert_flip_string_and_push_buffer() with\nport->lock held and printk()\
  \ from __build_all_zonelists() with\nzonelist_update_seq held.\n\n  CPU0       \
  \                            CPU1\n  ----                                   ----\n\
  \  pty_write() {\n    tty_insert_flip_string_and_push_buffer() {\n             \
  \                            __build_all_zonelists() {\n                       \
  \                    write_seqlock(&zonelist_update_seq);\n                    \
  \                       build_zonelists() {\n                                  \
  \           printk() {\n                                               vprintk()\
  \ {\n                                                 vprintk_default() {\n    \
  \                                               vprintk_emit() {\n             \
  \                                        console_unlock() {\n                  \
  \                                     console_flush_all() {\n                  \
  \                                       console_emit_next_record() {\n         \
  \                                                  con->write() = serial8250_console_write()\
  \ {\n      spin_lock_irqsave(&port->lock, flags);\n      tty_insert_flip_string()\
  \ {\n        tty_insert_flip_string_fixed_flag() {\n          __tty_buffer_request_room()\
  \ {\n            tty_buffer_alloc() {\n              kmalloc(GFP_ATOMIC | __GFP_NOWARN)\
  \ {\n                __alloc_pages_slowpath() {\n                  zonelist_iter_begin()\
  \ {\n                    read_seqbegin(&zonelist_update_seq); // spins forever because\
  \ zonelist_update_seq.seqcount is odd\n                                        \
  \                     spin_lock_irqsave(&port->lock, flags); // spins forever because\
  \ port->lock is held\n                    }\n                  }\n             \
  \   }\n              }\n            }\n          }\n        }\n      }\n      spin_unlock_irqrestore(&port->lock,\
  \ flags);\n                                                             // message\
  \ is printed to console\n                                                      \
  \       spin_unlock_irqrestore(&port->lock, flags);\n                          \
  \                                 }\n                                          \
  \               }\n                                                       }\n  \
  \                                                   }\n                        \
  \                           }\n                                                \
  \ }\n                                               }\n                        \
  \                     }\n                                           }\n        \
  \                                   write_sequnlock(&zonelist_update_seq);\n   \
  \                                      }\n    }\n  }\n\nThis deadlock scenario can\
  \ be eliminated by\n\n  preventing interrupt context from calling kmalloc(GFP_ATOMIC)\n\
  \nand\n\n  preventing printk() from calling console_flush_all()\n\nwhile zonelist_update_seq.seqcount\
  \ is odd.\n\nSince Petr Mladek thinks that __build_all_zonelists() can become a\n\
  candidate for deferring printk() [2], let's address this problem by\n\n  disabling\
  \ local interrupts in order to avoid kmalloc(GFP_ATOMIC)\n\nand\n\n  disabling synchronous\
  \ printk() in order to avoid console_flush_all()\n\n.\n\nAs a side effect of minimizing\
  \ duration of zonelist_update_seq.seqcount\nbeing odd by disabling synchronous printk(),\
  \ latency at\nread_seqbegin(&zonelist_update_seq) for both !__GFP_DIRECT_RECLAIM\
  \ and\n__GFP_DIRECT_RECLAIM allocation requests will be reduced.  Although, from\n\
  lockdep perspective, not calling read_seqbegin(&zonelist_update_seq) (i.e.\ndo not\
  \ record unnecessary locking dependency) from interrupt context is\nstill preferable,\
  \ even if we don't allow calling kmalloc(GFP_ATOMIC)\ninside\nwrite_seqlock(&zonelist_update_seq)/write_sequnlock(&zonelist_update_seq)\n\
  section...\n\nLink: https://lkml.kernel.org/r/8796b95c-3da3-5885-fddd-6ef55f30e4d3@I-love.SAKURA.ne.jp\n\
  Fixes: 3d36424b3b58 (\"mm/page_alloc: fix race condition between build_all_zonelists\
  \ and page allocation\")\nLink: https://lkml.kernel.org/r/ZCrs+1cDqPWTDFNM@alley\
  \ [2]\nReported-by: syzbot <syzbot+223c7461c58c58a4cb10@syzkaller.appspotmail.com>\n\
  \  Link: https://syzkaller.appspot.com/bug?extid=223c7461c58c58a4cb10 [1]\nSigned-off-by:\
  \ Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nAcked-by: Michal Hocko <mhocko@suse.com>\n\
  Acked-by: Mel Gorman <mgorman@techsingularity.net>\nCc: Petr Mladek <pmladek@suse.com>\n\
  Cc: David Hildenbrand <david@redhat.com>\nCc: Ilpo JÃ¤rvinen <ilpo.jarvinen@linux.intel.com>\n\
  Cc: John Ogness <john.ogness@linutronix.de>\nCc: Patrick Daly <quic_pdaly@quicinc.com>\n\
  Cc: Sergey Senozhatsky <senozhatsky@chromium.org>\nCc: Steven Rostedt <rostedt@goodmis.org>\n\
  Cc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n"
submodule:
- mm
hunk_count: 2
covered_count: 2
