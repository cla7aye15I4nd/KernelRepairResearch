id: 2d2aeadc6ce1e1f11d45
bug_link: https://syzkaller.appspot.com/bug?extid=2d2aeadc6ce1e1f11d45
title: possible deadlock in start_this_handle (3)
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 65974cb9107d9c6da18cefda22f84aeabc638b16
fix_commit: 68aaee147e597b495622b7c9038e5922c7c61f57
datetime: '2022-07-29T18:07:18-07:00'
fix_commit_message: 'mm: memcontrol: fix potential oom_lock recursion deadlock


  syzbot is reporting GFP_KERNEL allocation with oom_lock held when

  reporting memcg OOM [1].  If this allocation triggers the global OOM

  situation then the system can livelock because the GFP_KERNEL

  allocation with oom_lock held cannot trigger the global OOM killer

  because __alloc_pages_may_oom() fails to hold oom_lock.


  Fix this problem by removing the allocation from memory_stat_format()

  completely, and pass static buffer when calling from memcg OOM path.


  Note that the caller holding filesystem lock was the trigger for syzbot

  to report this locking dependency.  Doing GFP_KERNEL allocation with

  filesystem lock held can deadlock the system even without involving OOM

  situation.


  Link: https://syzkaller.appspot.com/bug?extid=2d2aeadc6ce1e1f11d45 [1]

  Link: https://lkml.kernel.org/r/86afb39f-8c65-bec2-6cfc-c5e3cd600c0b@I-love.SAKURA.ne.jp

  Fixes: c8713d0b23123759 ("mm: memcontrol: dump memory.stat during cgroup OOM")

  Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>

  Reported-by: syzbot <syzbot+2d2aeadc6ce1e1f11d45@syzkaller.appspotmail.com>

  Suggested-by: Michal Hocko <mhocko@suse.com>

  Acked-by: Michal Hocko <mhocko@suse.com>

  Cc: Johannes Weiner <hannes@cmpxchg.org>

  Cc: Roman Gushchin <roman.gushchin@linux.dev>

  Cc: Shakeel Butt <shakeelb@google.com>

  Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

  '
submodule:
- mm
hunk_count: 5
covered_count: 0
