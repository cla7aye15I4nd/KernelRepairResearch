id: e979d3597f48262cb4ee
bug_link: https://syzkaller.appspot.com/bug?extid=e979d3597f48262cb4ee
title: possible deadlock in smc_switch_to_fallback
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: f7a36b03a7320d1a3ba52f9305571eddad325a05
fix_commit: 7a61432dc81375be06b02f0061247d3efbdfce3a
datetime: '2021-11-22T14:51:45+00:00'
fix_commit_message: "net/smc: Avoid warning of possible recursive locking\n\nPossible\
  \ recursive locking is detected by lockdep when SMC\nfalls back to TCP. The corresponding\
  \ warnings are as follows:\n\n ============================================\n WARNING:\
  \ possible recursive locking detected\n 5.16.0-rc1+ #18 Tainted: G            E\n\
  \ --------------------------------------------\n wrk/1391 is trying to acquire lock:\n\
  \ ffff975246c8e7d8 (&ei->socket.wq.wait){..-.}-{3:3}, at: smc_switch_to_fallback+0x109/0x250\
  \ [smc]\n\n but task is already holding lock:\n ffff975246c8f918 (&ei->socket.wq.wait){..-.}-{3:3},\
  \ at: smc_switch_to_fallback+0xfe/0x250 [smc]\n\n other info that might help us\
  \ debug this:\n  Possible unsafe locking scenario:\n\n        CPU0\n        ----\n\
  \   lock(&ei->socket.wq.wait);\n   lock(&ei->socket.wq.wait);\n\n  *** DEADLOCK\
  \ ***\n\n  May be due to missing lock nesting notation\n\n 2 locks held by wrk/1391:\n\
  \  #0: ffff975246040130 (sk_lock-AF_SMC){+.+.}-{0:0}, at: smc_connect+0x43/0x150\
  \ [smc]\n  #1: ffff975246c8f918 (&ei->socket.wq.wait){..-.}-{3:3}, at: smc_switch_to_fallback+0xfe/0x250\
  \ [smc]\n\n stack backtrace:\n Call Trace:\n  <TASK>\n  dump_stack_lvl+0x56/0x7b\n\
  \  __lock_acquire+0x951/0x11f0\n  lock_acquire+0x27a/0x320\n  ? smc_switch_to_fallback+0x109/0x250\
  \ [smc]\n  ? smc_switch_to_fallback+0xfe/0x250 [smc]\n  _raw_spin_lock_irq+0x3b/0x80\n\
  \  ? smc_switch_to_fallback+0x109/0x250 [smc]\n  smc_switch_to_fallback+0x109/0x250\
  \ [smc]\n  smc_connect_fallback+0xe/0x30 [smc]\n  __smc_connect+0xcf/0x1090 [smc]\n\
  \  ? mark_held_locks+0x61/0x80\n  ? __local_bh_enable_ip+0x77/0xe0\n  ? lockdep_hardirqs_on+0xbf/0x130\n\
  \  ? smc_connect+0x12a/0x150 [smc]\n  smc_connect+0x12a/0x150 [smc]\n  __sys_connect+0x8a/0xc0\n\
  \  ? syscall_enter_from_user_mode+0x20/0x70\n  __x64_sys_connect+0x16/0x20\n  do_syscall_64+0x34/0x90\n\
  \  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThe nested locking in smc_switch_to_fallback()\
  \ is considered to\npossibly cause a deadlock because smc_wait->lock and clc_wait->lock\n\
  are the same type of lock. But actually it is safe so far since\nthere is no other\
  \ place trying to obtain smc_wait->lock when\nclc_wait->lock is held. So the patch\
  \ replaces spin_lock() with\nspin_lock_nested() to avoid false report by lockdep.\n\
  \nLink: https://lkml.org/lkml/2021/11/19/962\nFixes: 2153bd1e3d3d (\"Transfer remaining\
  \ wait queue entries during fallback\")\nReported-by: syzbot+e979d3597f48262cb4ee@syzkaller.appspotmail.com\n\
  Signed-off-by: Wen Gu <guwen@linux.alibaba.com>\nAcked-by: Tony Lu <tonylu@linux.alibaba.com>\n\
  Signed-off-by: David S. Miller <davem@davemloft.net>\n"
submodule:
- net/smc
hunk_count: 1
covered_count: 1
