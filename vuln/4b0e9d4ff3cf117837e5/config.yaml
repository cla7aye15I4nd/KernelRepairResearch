id: 4b0e9d4ff3cf117837e5
bug_link: https://syzkaller.appspot.com/bug?extid=4b0e9d4ff3cf117837e5
title: 'INFO: rcu detected stall in ip_set_uadd'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 83d0585f91da441a0b11bc5ff93f4cda56de6703
fix_commit: f66ee0410b1c3481ee75e5db9b34547b4d582465
datetime: '2020-02-22T12:00:06+01:00'
fix_commit_message: "netfilter: ipset: Fix \"INFO: rcu detected stall in hash_xxx\"\
  \ reports\n\nIn the case of huge hash:* types of sets, due to the single spinlock\
  \ of\na set the processing of the whole set under spinlock protection could take\n\
  too long.\n\nThere were four places where the whole hash table of the set was processed\n\
  from bucket to bucket under holding the spinlock:\n\n- During resizing a set, the\
  \ original set was locked to exclude kernel side\n  add/del element operations (userspace\
  \ add/del is excluded by the\n  nfnetlink mutex). The original set is actually just\
  \ read during the\n  resize, so the spinlocking is replaced with rcu locking of\
  \ regions.\n  However, thus there can be parallel kernel side add/del of entries.\n\
  \  In order not to loose those operations a backlog is added and replayed\n  after\
  \ the successful resize.\n- Garbage collection of timed out entries was also protected\
  \ by the spinlock.\n  In order not to lock too long, region locking is introduced\
  \ and a single\n  region is processed in one gc go. Also, the simple timer based\
  \ gc running\n  is replaced with a workqueue based solution. The internal book-keeping\n\
  \  (number of elements, size of extensions) is moved to region level due to\n  the\
  \ region locking.\n- Adding elements: when the max number of the elements is reached,\
  \ the gc\n  was called to evict the timed out entries. The new approach is that\
  \ the gc\n  is called just for the matching region, assuming that if the region\n\
  \  (proportionally) seems to be full, then the whole set does. We could scan\n \
  \ the other regions to check every entry under rcu locking, but for huge\n  sets\
  \ it'd mean a slowdown at adding elements.\n- Listing the set header data: when\
  \ the set was defined with timeout\n  support, the garbage collector was called\
  \ to clean up timed out entries\n  to get the correct element numbers and set size\
  \ values. Now the set is\n  scanned to check non-timed out entries, without actually\
  \ calling the gc\n  for the whole set.\n\nThanks to Florian Westphal for helping\
  \ me to solve the SOFTIRQ-safe ->\nSOFTIRQ-unsafe lock order issues during working\
  \ on the patch.\n\nReported-by: syzbot+4b0e9d4ff3cf117837e5@syzkaller.appspotmail.com\n\
  Reported-by: syzbot+c27b8d5010f45c666ed1@syzkaller.appspotmail.com\nReported-by:\
  \ syzbot+68a806795ac89df3aa1c@syzkaller.appspotmail.com\nFixes: 23c42a403a9c (\"\
  netfilter: ipset: Introduction of new commands and protocol version 7\")\nSigned-off-by:\
  \ Jozsef Kadlecsik <kadlec@netfilter.org>\n"
submodule:
- include/linux/netfilter/ipset
- net/netfilter
hunk_count: 52
covered_count: 8
