id: 232ebdbd36706c965ebf
bug_link: https://syzkaller.appspot.com/bug?extid=232ebdbd36706c965ebf
title: memory leak in regulatory_hint_core
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: be1236fce5f4ac94915cdca8c61bb6e0e1503b81
fix_commit: 399ab7fe0fa0d846881685fd4e57e9a8ef7559f7
datetime: '2022-12-26T08:58:33+00:00'
fix_commit_message: "net: sched: fix memory leak in tcindex_set_parms\n\nSyzkaller\
  \ reports a memory leak as follows:\n====================================\nBUG:\
  \ memory leak\nunreferenced object 0xffff88810c287f00 (size 256):\n  comm \"syz-executor105\"\
  , pid 3600, jiffies 4294943292 (age 12.990s)\n  hex dump (first 32 bytes):\n   \
  \ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00\
  \ 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace:\n    [<ffffffff814cf9f0>]\
  \ kmalloc_trace+0x20/0x90 mm/slab_common.c:1046\n    [<ffffffff839c9e07>] kmalloc\
  \ include/linux/slab.h:576 [inline]\n    [<ffffffff839c9e07>] kmalloc_array include/linux/slab.h:627\
  \ [inline]\n    [<ffffffff839c9e07>] kcalloc include/linux/slab.h:659 [inline]\n\
  \    [<ffffffff839c9e07>] tcf_exts_init include/net/pkt_cls.h:250 [inline]\n   \
  \ [<ffffffff839c9e07>] tcindex_set_parms+0xa7/0xbe0 net/sched/cls_tcindex.c:342\n\
  \    [<ffffffff839caa1f>] tcindex_change+0xdf/0x120 net/sched/cls_tcindex.c:553\n\
  \    [<ffffffff8394db62>] tc_new_tfilter+0x4f2/0x1100 net/sched/cls_api.c:2147\n\
  \    [<ffffffff8389e91c>] rtnetlink_rcv_msg+0x4dc/0x5d0 net/core/rtnetlink.c:6082\n\
  \    [<ffffffff839eba67>] netlink_rcv_skb+0x87/0x1d0 net/netlink/af_netlink.c:2540\n\
  \    [<ffffffff839eab87>] netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]\n\
  \    [<ffffffff839eab87>] netlink_unicast+0x397/0x4c0 net/netlink/af_netlink.c:1345\n\
  \    [<ffffffff839eb046>] netlink_sendmsg+0x396/0x710 net/netlink/af_netlink.c:1921\n\
  \    [<ffffffff8383e796>] sock_sendmsg_nosec net/socket.c:714 [inline]\n    [<ffffffff8383e796>]\
  \ sock_sendmsg+0x56/0x80 net/socket.c:734\n    [<ffffffff8383eb08>] ____sys_sendmsg+0x178/0x410\
  \ net/socket.c:2482\n    [<ffffffff83843678>] ___sys_sendmsg+0xa8/0x110 net/socket.c:2536\n\
  \    [<ffffffff838439c5>] __sys_sendmmsg+0x105/0x330 net/socket.c:2622\n    [<ffffffff83843c14>]\
  \ __do_sys_sendmmsg net/socket.c:2651 [inline]\n    [<ffffffff83843c14>] __se_sys_sendmmsg\
  \ net/socket.c:2648 [inline]\n    [<ffffffff83843c14>] __x64_sys_sendmmsg+0x24/0x30\
  \ net/socket.c:2648\n    [<ffffffff84605fd5>] do_syscall_x64 arch/x86/entry/common.c:50\
  \ [inline]\n    [<ffffffff84605fd5>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n\
  \    [<ffffffff84800087>] entry_SYSCALL_64_after_hwframe+0x63/0xcd\n====================================\n\
  \nKernel uses tcindex_change() to change an existing\nfilter properties.\n\nYet\
  \ the problem is that, during the process of changing,\nif `old_r` is retrieved\
  \ from `p->perfect`, then\nkernel uses tcindex_alloc_perfect_hash() to newly\nallocate\
  \ filter results, uses tcindex_filter_result_init()\nto clear the old filter result,\
  \ without destroying\nits tcf_exts structure, which triggers the above memory leak.\n\
  \nTo be more specific, there are only two source for the `old_r`,\naccording to\
  \ the tcindex_lookup(). `old_r` is retrieved from\n`p->perfect`, or `old_r` is retrieved\
  \ from `p->h`.\n\n  * If `old_r` is retrieved from `p->perfect`, kernel uses\ntcindex_alloc_perfect_hash()\
  \ to newly allocate the\nfilter results. Then `r` is assigned with `cp->perfect\
  \ + handle`,\nwhich is newly allocated. So condition `old_r && old_r != r` is\n\
  true in this situation, and kernel uses tcindex_filter_result_init()\nto clear the\
  \ old filter result, without destroying\nits tcf_exts structure\n\n  * If `old_r`\
  \ is retrieved from `p->h`, then `p->perfect` is NULL\naccording to the tcindex_lookup().\
  \ Considering that `cp->h`\nis directly copied from `p->h` and `p->perfect` is NULL,\n\
  `r` is assigned with `tcindex_lookup(cp, handle)`, whose value\nshould be the same\
  \ as `old_r`, so condition `old_r && old_r != r`\nis false in this situation, kernel\
  \ ignores using\ntcindex_filter_result_init() to clear the old filter result.\n\n\
  So only when `old_r` is retrieved from `p->perfect` does kernel use\ntcindex_filter_result_init()\
  \ to clear the old filter result, which\ntriggers the above memory leak.\n\nConsidering\
  \ that there already exists a tc_filter_wq workqueue\nto destroy the old tcindex_data\
  \ by tcindex_partial_destroy_work()\nat the end of tcindex_set_parms(), this patch\
  \ solves\nthis memory leak bug by removing this old filter result\nclearing part\
  \ and delegating it to the tc_filter_wq workqueue.\n\nNote that this patch doesn't\
  \ introduce any other issues. If\n`old_r` is retrieved from `p->perfect`, this patch\
  \ just\ndelegates old filter result clearing part to the\ntc_filter_wq workqueue;\
  \ If `old_r` is retrieved from `p->h`,\nkernel doesn't reach the old filter result\
  \ clearing part, so\nremoving this part has no effect.\n\n[Thanks to the suggestion\
  \ from Jakub Kicinski, Cong Wang, Paolo Abeni\nand Dmitry Vyukov]\n\nFixes: b9a24bb76bf6\
  \ (\"net_sched: properly handle failure case of tcf_exts_init()\")\nLink: https://lore.kernel.org/all/0000000000001de5c505ebc9ec59@google.com/\n\
  Reported-by: syzbot+232ebdbd36706c965ebf@syzkaller.appspotmail.com\nTested-by: syzbot+232ebdbd36706c965ebf@syzkaller.appspotmail.com\n\
  Cc: Cong Wang <cong.wang@bytedance.com>\nCc: Jakub Kicinski <kuba@kernel.org>\n\
  Cc: Paolo Abeni <pabeni@redhat.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nAcked-by:\
  \ Paolo Abeni <pabeni@redhat.com>\nSigned-off-by: Hawkins Jiawei <yin31149@gmail.com>\n\
  Signed-off-by: David S. Miller <davem@davemloft.net>\n"
submodule:
- net/sched
hunk_count: 3
covered_count: 1
