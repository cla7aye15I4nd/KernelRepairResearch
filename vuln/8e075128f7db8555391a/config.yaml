id: 8e075128f7db8555391a
bug_link: https://syzkaller.appspot.com/bug?extid=8e075128f7db8555391a
title: kernel BUG at mm/huge_memory.c:LINE!
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: d883544515aae54842c21730b880172e7894fde9
fix_commit: a53190a4aaa36494f4d7209fd1fcc6f2ee08e0e0
datetime: '2019-08-13T16:06:52-07:00'
fix_commit_message: "mm: mempolicy: handle vma with unmovable pages mapped correctly\
  \ in mbind\n\nWhen running syzkaller internally, we ran into the below bug on 4.9.x\n\
  kernel:\n\n  kernel BUG at mm/huge_memory.c:2124!\n  invalid opcode: 0000 [#1] SMP\
  \ KASAN\n  CPU: 0 PID: 1518 Comm: syz-executor107 Not tainted 4.9.168+ #2\n  Hardware\
  \ name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.5.1 01/01/2011\n  task: ffff880067b34900\
  \ task.stack: ffff880068998000\n  RIP: split_huge_page_to_list+0x8fb/0x1030 mm/huge_memory.c:2124\n\
  \  Call Trace:\n    split_huge_page include/linux/huge_mm.h:100 [inline]\n    queue_pages_pte_range+0x7e1/0x1480\
  \ mm/mempolicy.c:538\n    walk_pmd_range mm/pagewalk.c:50 [inline]\n    walk_pud_range\
  \ mm/pagewalk.c:90 [inline]\n    walk_pgd_range mm/pagewalk.c:116 [inline]\n   \
  \ __walk_page_range+0x44a/0xdb0 mm/pagewalk.c:208\n    walk_page_range+0x154/0x370\
  \ mm/pagewalk.c:285\n    queue_pages_range+0x115/0x150 mm/mempolicy.c:694\n    do_mbind\
  \ mm/mempolicy.c:1241 [inline]\n    SYSC_mbind+0x3c3/0x1030 mm/mempolicy.c:1370\n\
  \    SyS_mbind+0x46/0x60 mm/mempolicy.c:1352\n    do_syscall_64+0x1d2/0x600 arch/x86/entry/common.c:282\n\
  \    entry_SYSCALL_64_after_swapgs+0x5d/0xdb\n  Code: c7 80 1c 02 00 e8 26 0a 76\
  \ 01 <0f> 0b 48 c7 c7 40 46 45 84 e8 4c\n  RIP  [<ffffffff81895d6b>] split_huge_page_to_list+0x8fb/0x1030\
  \ mm/huge_memory.c:2124\n   RSP <ffff88006899f980>\n\nwith the below test:\n\n \
  \ uint64_t r[1] = {0xffffffffffffffff};\n\n  int main(void)\n  {\n        syscall(__NR_mmap,\
  \ 0x20000000, 0x1000000, 3, 0x32, -1, 0);\n                                intptr_t\
  \ res = 0;\n        res = syscall(__NR_socket, 0x11, 3, 0x300);\n        if (res\
  \ != -1)\n                r[0] = res;\n        *(uint32_t*)0x20000040 = 0x10000;\n\
  \        *(uint32_t*)0x20000044 = 1;\n        *(uint32_t*)0x20000048 = 0xc520;\n\
  \        *(uint32_t*)0x2000004c = 1;\n        syscall(__NR_setsockopt, r[0], 0x107,\
  \ 0xd, 0x20000040, 0x10);\n        syscall(__NR_mmap, 0x20fed000, 0x10000, 0, 0x8811,\
  \ r[0], 0);\n        *(uint64_t*)0x20000340 = 2;\n        syscall(__NR_mbind, 0x20ff9000,\
  \ 0x4000, 0x4002, 0x20000340, 0x45d4, 3);\n        return 0;\n  }\n\nActually the\
  \ test does:\n\n  mmap(0x20000000, 16777216, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,\
  \ -1, 0) = 0x20000000\n  socket(AF_PACKET, SOCK_RAW, 768)        = 3\n  setsockopt(3,\
  \ SOL_PACKET, PACKET_TX_RING, {block_size=65536, block_nr=1, frame_size=50464, frame_nr=1},\
  \ 16) = 0\n  mmap(0x20fed000, 65536, PROT_NONE, MAP_SHARED|MAP_FIXED|MAP_POPULATE|MAP_DENYWRITE,\
  \ 3, 0) = 0x20fed000\n  mbind(..., MPOL_MF_STRICT|MPOL_MF_MOVE) = 0\n\nThe setsockopt()\
  \ would allocate compound pages (16 pages in this test)\nfor packet tx ring, then\
  \ the mmap() would call packet_mmap() to map the\npages into the user address space\
  \ specified by the mmap() call.\n\nWhen calling mbind(), it would scan the vma to\
  \ queue the pages for\nmigration to the new node.  It would split any huge page\
  \ since 4.9\ndoesn't support THP migration, however, the packet tx ring compound\n\
  pages are not THP and even not movable.  So, the above bug is triggered.\n\nHowever,\
  \ the later kernel is not hit by this issue due to commit\nd44d363f6578 (\"mm: don't\
  \ assume anonymous pages have SwapBacked flag\"),\nwhich just removes the PageSwapBacked\
  \ check for a different reason.\n\nBut, there is a deeper issue.  According to the\
  \ semantic of mbind(), it\nshould return -EIO if MPOL_MF_MOVE or MPOL_MF_MOVE_ALL\
  \ was specified and\nMPOL_MF_STRICT was also specified, but the kernel was unable\
  \ to move all\nexisting pages in the range.  The tx ring of the packet socket is\n\
  definitely not movable, however, mbind() returns success for this case.\n\nAlthough\
  \ the most socket file associates with non-movable pages, but XDP\nmay have movable\
  \ pages from gup.  So, it sounds not fine to just check\nthe underlying file type\
  \ of vma in vma_migratable().\n\nChange migrate_page_add() to check if the page\
  \ is movable or not, if it\nis unmovable, just return -EIO.  But do not abort pte\
  \ walk immediately,\nsince there may be pages off LRU temporarily.  We should migrate\
  \ other\npages if MPOL_MF_MOVE* is specified.  Set has_unmovable flag if some\n\
  paged could not be not moved, then return -EIO for mbind() eventually.\n\nWith this\
  \ change the above test would return -EIO as expected.\n\n[yang.shi@linux.alibaba.com:\
  \ fix review comments from Vlastimil]\n  Link: http://lkml.kernel.org/r/1563556862-54056-3-git-send-email-yang.shi@linux.alibaba.com\n\
  Link: http://lkml.kernel.org/r/1561162809-59140-3-git-send-email-yang.shi@linux.alibaba.com\n\
  Signed-off-by: Yang Shi <yang.shi@linux.alibaba.com>\nReviewed-by: Vlastimil Babka\
  \ <vbabka@suse.cz>\nCc: Michal Hocko <mhocko@suse.com>\nCc: Mel Gorman <mgorman@techsingularity.net>\n\
  Cc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n\
  Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n"
submodule:
- mm
hunk_count: 6
covered_count: 0
