id: 358c9ab4c93da7b7238c
bug_link: https://syzkaller.appspot.com/bug?extid=358c9ab4c93da7b7238c
title: 'INFO: task hung in misc_open (4)'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 09d3154a6f0f0bb5b604832095804780f3684b96
fix_commit: 8386c414e27caba8501119948e9551e52b527f59
datetime: '2022-07-26T20:39:01+02:00'
fix_commit_message: "PM: hibernate: defer device probing when resuming from hibernation\n\
  \nsyzbot is reporting hung task at misc_open() [1], for there is a race\nwindow\
  \ of AB-BA deadlock which involves probe_count variable. Currently\nwait_for_device_probe()\
  \ from snapshot_open() from misc_open() can sleep\nforever with misc_mtx held if\
  \ probe_count cannot become 0.\n\nWhen a device is probed by hub_event() work function,\
  \ probe_count is\nincremented before the probe function starts, and probe_count\
  \ is\ndecremented after the probe function completed.\n\nThere are three cases that\
  \ can prevent probe_count from dropping to 0.\n\n  (a) A device being probed stopped\
  \ responding (i.e. broken/malicious\n      hardware).\n\n  (b) A process emulating\
  \ a USB device using /dev/raw-gadget interface\n      stopped responding for some\
  \ reason.\n\n  (c) New device probe requests keeps coming in before existing device\n\
  \      probe requests complete.\n\nThe phenomenon syzbot is reporting is (b). A\
  \ process which is holding\nsystem_transition_mutex and misc_mtx is waiting for\
  \ probe_count to become\n0 inside wait_for_device_probe(), but the probe function\
  \ which is called\n from hub_event() work function is waiting for the processes\
  \ which are\nblocked at mutex_lock(&misc_mtx) to respond via /dev/raw-gadget interface.\n\
  \nThis patch mitigates (b) by deferring wait_for_device_probe() from\nsnapshot_open()\
  \ to snapshot_write() and snapshot_ioctl(). Please note that\nthe possibility of\
  \ (b) remains as long as any thread which is emulating a\nUSB device via /dev/raw-gadget\
  \ interface can be blocked by uninterruptible\nblocking operations (e.g. mutex_lock()).\n\
  \nPlease also note that (a) and (c) are not addressed. Regarding (c), we\nshould\
  \ change the code to wait for only one device which contains the\nimage for resuming\
  \ from hibernation. I don't know how to address (a), for\nuse of timeout for wait_for_device_probe()\
  \ might result in loss of user\ndata in the image. Maybe we should require the userland\
  \ to wait for the\nimage device before opening /dev/snapshot interface.\n\nLink:\
  \ https://syzkaller.appspot.com/bug?extid=358c9ab4c93da7b7238c [1]\nReported-by:\
  \ syzbot <syzbot+358c9ab4c93da7b7238c@syzkaller.appspotmail.com>\nSigned-off-by:\
  \ Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nTested-by: syzbot <syzbot+358c9ab4c93da7b7238c@syzkaller.appspotmail.com>\n\
  Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>\n"
submodule:
- kernel/power
hunk_count: 4
covered_count: 2
