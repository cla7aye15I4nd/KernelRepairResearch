id: 62e474dd92a35e3060d8
bug_link: https://syzkaller.appspot.com/bug?extid=62e474dd92a35e3060d8
title: 'BUG: corrupted list in netif_napi_add'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: e5d5aadcf3cd59949316df49c27cb21788d7efe4
fix_commit: 0315a075f1343966ea2d9a085666a88a69ea6a3d
datetime: '2021-11-10T17:45:15-08:00'
fix_commit_message: "net: fix premature exit from NAPI state polling in napi_disable()\n\
  \nCommit 719c57197010 (\"net: make napi_disable() symmetric with\nenable\") accidentally\
  \ introduced a bug sometimes leading to a kernel\nBUG when bringing an iface up/down\
  \ under heavy traffic load.\n\nPrior to this commit, napi_disable() was polling\
  \ n->state until\nnone of (NAPIF_STATE_SCHED | NAPIF_STATE_NPSVC) is set and then\n\
  always flip them. Now there's a possibility to get away with the\nNAPIF_STATE_SCHE\
  \ unset as 'continue' drops us to the cmpxchg()\ncall with an uninitialized variable,\
  \ rather than straight to\nanother round of the state check.\n\nError path looks\
  \ like:\n\nnapi_disable():\nunsigned long val, new; /* new is uninitialized */\n\
  \ndo {\n\tval = READ_ONCE(n->state); /* NAPIF_STATE_NPSVC and/or\n\t\t\t\t     \
  \ NAPIF_STATE_SCHED is set */\n\tif (val & (NAPIF_STATE_SCHED | NAPIF_STATE_NPSVC))\
  \ { /* true */\n\t\tusleep_range(20, 200);\n\t\tcontinue; /* go straight to the\
  \ condition check */\n\t}\n\tnew = val | <...>\n} while (cmpxchg(&n->state, val,\
  \ new) != val); /* state == val, cmpxchg()\n\t\t\t\t\t\t  writes garbage */\n\n\
  napi_enable():\ndo {\n\tval = READ_ONCE(n->state);\n\tBUG_ON(!test_bit(NAPI_STATE_SCHED,\
  \ &val)); /* 50/50 boom */\n<...>\n\nwhile the typical BUG splat is like:\n\n[ \
  \ 172.652461] ------------[ cut here ]------------\n[  172.652462] kernel BUG at\
  \ net/core/dev.c:6937!\n[  172.656914] invalid opcode: 0000 [#1] PREEMPT SMP PTI\n\
  [  172.661966] CPU: 36 PID: 2829 Comm: xdp_redirect_cp Tainted: G          I   \
  \    5.15.0 #42\n[  172.670222] Hardware name: Intel Corporation S2600WFT/S2600WFT,\
  \ BIOS SE5C620.86B.02.01.0014.082620210524 08/26/2021\n[  172.680646] RIP: 0010:napi_enable+0x5a/0xd0\n\
  [  172.684832] Code: 07 49 81 cc 00 01 00 00 4c 89 e2 48 89 d8 80 e6 fb f0 48 0f\
  \ b1 55 10 48 39 c3 74 10 48 8b 5d 10 f6 c7 04 75 3d f6 c3 01 75 b4 <0f> 0b 5b 5d\
  \ 41 5c c3 65 ff 05 b8 e5 61 53 48 c7 c6 c0 f3 34 ad 48\n[  172.703578] RSP: 0018:ffffa3c9497477a8\
  \ EFLAGS: 00010246\n[  172.708803] RAX: ffffa3c96615a014 RBX: 0000000000000000 RCX:\
  \ ffff8a4b575301a0\n< snip >\n[  172.782403] Call Trace:\n[  172.784857]  <TASK>\n\
  [  172.786963]  ice_up_complete+0x6f/0x210 [ice]\n[  172.791349]  ice_xdp+0x136/0x320\
  \ [ice]\n[  172.795108]  ? ice_change_mtu+0x180/0x180 [ice]\n[  172.799648]  dev_xdp_install+0x61/0xe0\n\
  [  172.803401]  dev_xdp_attach+0x1e0/0x550\n[  172.807240]  dev_change_xdp_fd+0x1e6/0x220\n\
  [  172.811338]  do_setlink+0xee8/0x1010\n[  172.814917]  rtnl_setlink+0xe5/0x170\n\
  [  172.818499]  ? bpf_lsm_binder_set_context_mgr+0x10/0x10\n[  172.823732]  ? security_capable+0x36/0x50\n\
  < snip >\n\nFix this by replacing 'do { } while (cmpxchg())' with an \"infinite\"\
  \nfor-loop with an explicit break.\n\nFrom v1 [0]:\n - just use a for-loop to simplify\
  \ both the fix and the existing\n   code (Eric).\n\n[0] https://lore.kernel.org/netdev/20211110191126.1214-1-alexandr.lobakin@intel.com\n\
  \nFixes: 719c57197010 (\"net: make napi_disable() symmetric with enable\")\nSuggested-by:\
  \ Eric Dumazet <edumazet@google.com> # for-loop\nSigned-off-by: Alexander Lobakin\
  \ <alexandr.lobakin@intel.com>\nReviewed-by: Jesse Brandeburg <jesse.brandeburg@intel.com>\n\
  Reviewed-by: Eric Dumazet <edumazet@google.com>\nLink: https://lore.kernel.org/r/20211110195605.1304-1-alexandr.lobakin@intel.com\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n"
submodule:
- net/core
hunk_count: 2
covered_count: 2
