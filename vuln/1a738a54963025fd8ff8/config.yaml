id: 1a738a54963025fd8ff8
bug_link: https://syzkaller.appspot.com/bug?extid=1a738a54963025fd8ff8
title: WARNING in fuse_evict_inode
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 964d32e512670c7b87870e30cfed2303da86d614
fix_commit: 5c791fe1e2a4f401f819065ea4fc0450849f1818
datetime: '2021-10-22T17:03:01+02:00'
fix_commit_message: "fuse: make sure reclaim doesn't write the inode\n\nIn writeback\
  \ cache mode mtime/ctime updates are cached, and flushed to the\nserver using the\
  \ ->write_inode() callback.\n\nClosing the file will result in a dirty inode being\
  \ immediately written,\nbut in other cases the inode can remain dirty after all\
  \ references are\ndropped.  This result in the inode being written back from reclaim,\
  \ which\ncan deadlock on a regular allocation while the request is being served.\n\
  \nThe usual mechanisms (GFP_NOFS/PF_MEMALLOC*) don't work for FUSE, because\nserving\
  \ a request involves unrelated userspace process(es).\n\nInstead do the same as\
  \ for dirty pages: make sure the inode is written\nbefore the last reference is\
  \ gone.\n\n - fallocate(2)/copy_file_range(2): these call file_update_time() or\n\
  \   file_modified(), so flush the inode before returning from the call\n\n - unlink(2),\
  \ link(2) and rename(2): these call fuse_update_ctime(), so\n   flush the ctime\
  \ directly from this helper\n\nReported-by: chenguanyou <chenguanyou@xiaomi.com>\n\
  Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>\n"
submodule:
- fs/fuse
hunk_count: 6
covered_count: 1
