id: d327a1f3b12e1e206c16
bug_link: https://syzkaller.appspot.com/bug?extid=d327a1f3b12e1e206c16
title: memory leak in nr_create (3)
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 143492fce36161402fa2f45a0756de7ff69c366a
fix_commit: 0b9130247f3b6a1122478471ff0e014ea96bb735
datetime: '2024-06-17T13:06:23+01:00'
fix_commit_message: "netrom: Fix a memory leak in nr_heartbeat_expiry()\n\nsyzbot\
  \ reported a memory leak in nr_create() [0].\n\nCommit 409db27e3a2e (\"netrom: Fix\
  \ use-after-free of a listening socket.\")\nadded sock_hold() to the nr_heartbeat_expiry()\
  \ function, where\na) a socket has a SOCK_DESTROY flag or\nb) a listening socket\
  \ has a SOCK_DEAD flag.\n\nBut in the case \"a,\" when the SOCK_DESTROY flag is\
  \ set, the file descriptor\nhas already been closed and the nr_release() function\
  \ has been called.\nSo it makes no sense to hold the reference count because no\
  \ one will\ncall another nr_destroy_socket() and put it as in the case \"b.\"\n\n\
  nr_connect\n  nr_establish_data_link\n    nr_start_heartbeat\n\nnr_release\n  switch\
  \ (nr->state)\n  case NR_STATE_3\n    nr->state = NR_STATE_2\n    sock_set_flag(sk,\
  \ SOCK_DESTROY);\n\n                        nr_rx_frame\n                      \
  \    nr_process_rx_frame\n                            switch (nr->state)\n     \
  \                       case NR_STATE_2\n                              nr_state2_machine()\n\
  \                                nr_disconnect()\n                             \
  \     nr_sk(sk)->state = NR_STATE_0\n                                  sock_set_flag(sk,\
  \ SOCK_DEAD)\n\n                        nr_heartbeat_expiry\n                  \
  \        switch (nr->state)\n                          case NR_STATE_0\n       \
  \                     if (sock_flag(sk, SOCK_DESTROY) ||\n                     \
  \          (sk->sk_state == TCP_LISTEN\n                                 && sock_flag(sk,\
  \ SOCK_DEAD)))\n                               sock_hold()  // ( !!! )\n       \
  \                        nr_destroy_socket()\n\nTo fix the memory leak, let's call\
  \ sock_hold() only for a listening socket.\n\nFound by InfoTeCS on behalf of Linux\
  \ Verification Center\n(linuxtesting.org) with Syzkaller.\n\n[0]: https://syzkaller.appspot.com/bug?extid=d327a1f3b12e1e206c16\n\
  \nReported-by: syzbot+d327a1f3b12e1e206c16@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=d327a1f3b12e1e206c16\n\
  Fixes: 409db27e3a2e (\"netrom: Fix use-after-free of a listening socket.\")\nSigned-off-by:\
  \ Gavrilov Ilia <Ilia.Gavrilov@infotecs.ru>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n"
submodule:
- net/netrom
hunk_count: 1
covered_count: 0
