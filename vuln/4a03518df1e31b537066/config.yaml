id: 4a03518df1e31b537066
bug_link: https://syzkaller.appspot.com/bug?extid=4a03518df1e31b537066
title: 'KCSAN: data-race in __es_find_extent_range / __es_find_extent_range (6)'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 00d873c17e29cc32d90ca852b82685f1673acaa5
fix_commit: 492888df0c7b42fc0843631168b0021bc4caee84
datetime: '2023-05-13T18:05:04-04:00'
fix_commit_message: 'ext4: fix data races when using cached status extents


  When using cached extent stored in extent status tree in tree->cache_es

  another process holding ei->i_es_lock for reading can be racing with us

  setting new value of tree->cache_es. If the compiler would decide to

  refetch tree->cache_es at an unfortunate moment, it could result in a

  bogus in_range() check. Fix the possible race by using READ_ONCE() when

  using tree->cache_es only under ei->i_es_lock for reading.


  Cc: stable@kernel.org

  Reported-by: syzbot+4a03518df1e31b537066@syzkaller.appspotmail.com

  Link: https://lore.kernel.org/all/000000000000d3b33905fa0fd4a6@google.com

  Suggested-by: Dmitry Vyukov <dvyukov@google.com>

  Signed-off-by: Jan Kara <jack@suse.cz>

  Link: https://lore.kernel.org/r/20230504125524.10802-1-jack@suse.cz

  Signed-off-by: Theodore Ts''o <tytso@mit.edu>

  '
submodule:
- fs/ext4
hunk_count: 3
covered_count: 2
