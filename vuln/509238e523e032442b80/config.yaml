id: 509238e523e032442b80
bug_link: https://syzkaller.appspot.com/bug?extid=509238e523e032442b80
title: possible deadlock in rfkill_send_events
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: b2f750c3a80b285cd60c9346f8c96bd0a2a66cde
fix_commit: f2ac54ebf85615a6d78f5eb213a8bbeeb17ebe5d
datetime: '2023-10-11T16:55:10+02:00'
fix_commit_message: 'net: rfkill: reduce data->mtx scope in rfkill_fop_open


  In syzbot runs, lockdep reports that there''s a (potential)

  deadlock here of data->mtx being locked recursively. This

  isn''t really a deadlock since they are different instances,

  but lockdep cannot know, and teaching it would be far more

  difficult than other fixes.


  At the same time we don''t even really _need_ the mutex to

  be locked in rfkill_fop_open(), since we''re modifying only

  a completely fresh instance of ''data'' (struct rfkill_data)

  that''s not yet added to the global list.


  However, to avoid any reordering etc. within the globally

  locked section, and to make the code look more symmetric,

  we should still lock the data->events list manipulation,

  but also need to lock _only_ that. So do that.


  Reported-by: syzbot+509238e523e032442b80@syzkaller.appspotmail.com

  Fixes: 2c3dfba4cf84 ("rfkill: sync before userspace visibility/changes")

  Signed-off-by: Johannes Berg <johannes.berg@intel.com>

  '
submodule:
- net/rfkill
hunk_count: 3
covered_count: 3
