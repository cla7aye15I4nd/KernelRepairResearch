id: f3f3eef1d2100200e593
bug_link: https://syzkaller.appspot.com/bug?extid=f3f3eef1d2100200e593
title: 'KASAN: slab-use-after-free Read in unix_del_edges'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 0ff1db480c7e06f14078937642695334a0890aee
fix_commit: 1af2dface5d286dd1f2f3405a0d6fa9f2c8fb998
datetime: '2024-04-23T13:57:35+02:00'
fix_commit_message: "af_unix: Don't access successor in unix_del_edges() during GC.\n\
  \nsyzbot reported use-after-free in unix_del_edges().  [0]\n\nWhat the repro does\
  \ is basically repeat the following quickly.\n\n  1. pass a fd of an AF_UNIX socket\
  \ to itself\n\n    socketpair(AF_UNIX, SOCK_DGRAM, 0, [3, 4]) = 0\n    sendmsg(3,\
  \ {..., msg_control=[{cmsg_len=20, cmsg_level=SOL_SOCKET,\n                    \
  \               cmsg_type=SCM_RIGHTS, cmsg_data=[4]}], ...}, 0) = 0\n\n  2. pass\
  \ other fds of AF_UNIX sockets to the socket above\n\n    socketpair(AF_UNIX, SOCK_SEQPACKET,\
  \ 0, [5, 6]) = 0\n    sendmsg(3, {..., msg_control=[{cmsg_len=48, cmsg_level=SOL_SOCKET,\n\
  \                                   cmsg_type=SCM_RIGHTS, cmsg_data=[5, 6]}], ...},\
  \ 0) = 0\n\n  3. close all sockets\n\nHere, two skb are created, and every unix_edge->successor\
  \ is the first\nsocket.  Then, __unix_gc() will garbage-collect the two skb:\n\n\
  \  (a) free skb with self-referencing fd\n  (b) free skb holding other sockets\n\
  \nAfter (a), the self-referencing socket will be scheduled to be freed\nlater by\
  \ the delayed_fput() task.\n\nsyzbot repeated the sequences above (1. ~ 3.) quickly\
  \ and triggered\nthe task concurrently while GC was running.\n\nSo, at (b), the\
  \ socket was already freed, and accessing it was illegal.\n\nunix_del_edges() accesses\
  \ the receiver socket as edge->successor to\noptimise GC.  However, we should not\
  \ do it during GC.\n\nGarbage-collecting sockets does not change the shape of the\
  \ rest\nof the graph, so we need not call unix_update_graph() to update\nunix_graph_grouped\
  \ when we purge skb.\n\nHowever, if we clean up all loops in the unix_walk_scc_fast()\
  \ path,\nunix_graph_maybe_cyclic remains unchanged (true), and __unix_gc()\nwill\
  \ call unix_walk_scc_fast() continuously even though there is no\nsocket to garbage-collect.\n\
  \nTo keep that optimisation while fixing UAF, let's add the same\nupdating logic\
  \ of unix_graph_maybe_cyclic in unix_walk_scc_fast()\nas done in unix_walk_scc()\
  \ and __unix_walk_scc().\n\nNote that when unix_del_edges() is called from other\
  \ places, the\nreceiver socket is always alive:\n\n  - sendmsg: the successor's\
  \ sk_refcnt is bumped by sock_hold()\n             unix_find_other() for SOCK_DGRAM,\
  \ connect() for SOCK_STREAM\n\n  - recvmsg: the successor is the receiver, and its\
  \ fd is alive\n\n[0]:\nBUG: KASAN: slab-use-after-free in unix_edge_successor net/unix/garbage.c:109\
  \ [inline]\nBUG: KASAN: slab-use-after-free in unix_del_edge net/unix/garbage.c:165\
  \ [inline]\nBUG: KASAN: slab-use-after-free in unix_del_edges+0x148/0x630 net/unix/garbage.c:237\n\
  Read of size 8 at addr ffff888079c6e640 by task kworker/u8:6/1099\n\nCPU: 0 PID:\
  \ 1099 Comm: kworker/u8:6 Not tainted 6.9.0-rc4-next-20240418-syzkaller #0\nHardware\
  \ name: Google Google Compute Engine/Google Compute Engine, BIOS Google 03/27/2024\n\
  Workqueue: events_unbound __unix_gc\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88\
  \ [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:114\n print_address_description\
  \ mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n\
  \ kasan_report+0x143/0x180 mm/kasan/report.c:601\n unix_edge_successor net/unix/garbage.c:109\
  \ [inline]\n unix_del_edge net/unix/garbage.c:165 [inline]\n unix_del_edges+0x148/0x630\
  \ net/unix/garbage.c:237\n unix_destroy_fpl+0x59/0x210 net/unix/garbage.c:298\n\
  \ unix_detach_fds net/unix/af_unix.c:1811 [inline]\n unix_destruct_scm+0x13e/0x210\
  \ net/unix/af_unix.c:1826\n skb_release_head_state+0x100/0x250 net/core/skbuff.c:1127\n\
  \ skb_release_all net/core/skbuff.c:1138 [inline]\n __kfree_skb net/core/skbuff.c:1154\
  \ [inline]\n kfree_skb_reason+0x16d/0x3b0 net/core/skbuff.c:1190\n __skb_queue_purge_reason\
  \ include/linux/skbuff.h:3251 [inline]\n __skb_queue_purge include/linux/skbuff.h:3256\
  \ [inline]\n __unix_gc+0x1732/0x1830 net/unix/garbage.c:575\n process_one_work kernel/workqueue.c:3218\
  \ [inline]\n process_scheduled_works+0xa2c/0x1830 kernel/workqueue.c:3299\n worker_thread+0x86d/0xd70\
  \ kernel/workqueue.c:3380\n kthread+0x2f0/0x390 kernel/kthread.c:389\n ret_from_fork+0x4b/0x80\
  \ arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\
  \ </TASK>\n\nAllocated by task 14427:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n\
  \ kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n unpoison_slab_object mm/kasan/common.c:312\
  \ [inline]\n __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:338\n kasan_slab_alloc\
  \ include/linux/kasan.h:201 [inline]\n slab_post_alloc_hook mm/slub.c:3897 [inline]\n\
  \ slab_alloc_node mm/slub.c:3957 [inline]\n kmem_cache_alloc_noprof+0x135/0x290\
  \ mm/slub.c:3964\n sk_prot_alloc+0x58/0x210 net/core/sock.c:2074\n sk_alloc+0x38/0x370\
  \ net/core/sock.c:2133\n unix_create1+0xb4/0x770\n unix_create+0x14e/0x200 net/unix/af_unix.c:1034\n\
  \ __sock_create+0x490/0x920 net/socket.c:1571\n sock_create net/socket.c:1622 [inline]\n\
  \ __sys_socketpair+0x33e/0x720 net/socket.c:1773\n __do_sys_socketpair net/socket.c:1822\
  \ [inline]\n __se_sys_socketpair net/socket.c:1819 [inline]\n __x64_sys_socketpair+0x9b/0xb0\
  \ net/socket.c:1819\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf5/0x240\
  \ arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\nFreed\
  \ by task 1805:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80\
  \ mm/kasan/common.c:68\n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579\n\
  \ poison_slab_object+0xe0/0x150 mm/kasan/common.c:240\n __kasan_slab_free+0x37/0x60\
  \ mm/kasan/common.c:256\n kasan_slab_free include/linux/kasan.h:184 [inline]\n slab_free_hook\
  \ mm/slub.c:2190 [inline]\n slab_free mm/slub.c:4393 [inline]\n kmem_cache_free+0x145/0x340\
  \ mm/slub.c:4468\n sk_prot_free net/core/sock.c:2114 [inline]\n __sk_destruct+0x467/0x5f0\
  \ net/core/sock.c:2208\n sock_put include/net/sock.h:1948 [inline]\n unix_release_sock+0xa8b/0xd20\
  \ net/unix/af_unix.c:665\n unix_release+0x91/0xc0 net/unix/af_unix.c:1049\n __sock_release\
  \ net/socket.c:659 [inline]\n sock_close+0xbc/0x240 net/socket.c:1421\n __fput+0x406/0x8b0\
  \ fs/file_table.c:422\n delayed_fput+0x59/0x80 fs/file_table.c:445\n process_one_work\
  \ kernel/workqueue.c:3218 [inline]\n process_scheduled_works+0xa2c/0x1830 kernel/workqueue.c:3299\n\
  \ worker_thread+0x86d/0xd70 kernel/workqueue.c:3380\n kthread+0x2f0/0x390 kernel/kthread.c:389\n\
  \ ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x1a/0x30\
  \ arch/x86/entry/entry_64.S:244\n\nThe buggy address belongs to the object at ffff888079c6e000\n\
  \ which belongs to the cache UNIX of size 1920\nThe buggy address is located 1600\
  \ bytes inside of\n freed 1920-byte region [ffff888079c6e000, ffff888079c6e780)\n\
  \nReported-by: syzbot+f3f3eef1d2100200e593@syzkaller.appspotmail.com\nCloses: https://syzkaller.appspot.com/bug?extid=f3f3eef1d2100200e593\n\
  Fixes: 77e5593aebba (\"af_unix: Skip GC if no cycle exists.\")\nFixes: fd86344823b5\
  \ (\"af_unix: Try not to hold unix_gc_lock during accept().\")\nSigned-off-by: Kuniyuki\
  \ Iwashima <kuniyu@amazon.com>\nLink: https://lore.kernel.org/r/20240419235102.31707-1-kuniyu@amazon.com\n\
  Signed-off-by: Paolo Abeni <pabeni@redhat.com>\n"
submodule:
- net/unix
hunk_count: 5
covered_count: 5
