id: 4e6e7e4279d046613bc5
bug_link: https://syzkaller.appspot.com/bug?extid=4e6e7e4279d046613bc5
title: 'KASAN: slab-out-of-bounds Read in ea_get (4)'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: b5799dd77054c1ec49b0088b006c9908e256843b
fix_commit: fdf480da5837c23b146c4743c18de97202fcab37
datetime: '2025-02-19T16:20:14-06:00'
fix_commit_message: "jfs: fix slab-out-of-bounds read in ea_get()\n\nDuring the \"\
  size_check\" label in ea_get(), the code checks if the extended\nattribute list\
  \ (xattr) size matches ea_size. If not, it logs\n\"ea_get: invalid extended attribute\"\
  \ and calls print_hex_dump().\n\nHere, EALIST_SIZE(ea_buf->xattr) returns 4110417968,\
  \ which exceeds\nINT_MAX (2,147,483,647). Then ea_size is clamped:\n\n\tint size\
  \ = clamp_t(int, ea_size, 0, EALIST_SIZE(ea_buf->xattr));\n\nAlthough clamp_t aims\
  \ to bound ea_size between 0 and 4110417968, the upper\nlimit is treated as an int,\
  \ causing an overflow above 2^31 - 1. This leads\n\"size\" to wrap around and become\
  \ negative (-184549328).\n\nThe \"size\" is then passed to print_hex_dump() (called\
  \ \"len\" in\nprint_hex_dump()), it is passed as type size_t (an unsigned\ntype),\
  \ this is then stored inside a variable called\n\"int remaining\", which is then\
  \ assigned to \"int linelen\" which\nis then passed to hex_dump_to_buffer(). In\
  \ print_hex_dump()\nthe for loop, iterates through 0 to len-1, where len is\n18446744073525002176,\
  \ calling hex_dump_to_buffer()\non each iteration:\n\n\tfor (i = 0; i < len; i +=\
  \ rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\
  \n\t\thex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t   linebuf,\
  \ sizeof(linebuf), ascii);\n\n\t\t...\n\t}\n\nThe expected stopping condition (i\
  \ < len) is effectively broken\nsince len is corrupted and very large. This eventually\
  \ leads to\nthe \"ptr+i\" being passed to hex_dump_to_buffer() to get closer\nto\
  \ the end of the actual bounds of \"ptr\", eventually an out of\nbounds access is\
  \ done in hex_dump_to_buffer() in the following\nfor loop:\n\n\tfor (j = 0; j <\
  \ len; j++) {\n\t\t\tif (linebuflen < lx + 2)\n\t\t\t\tgoto overflow2;\n\t\t\tch\
  \ = ptr[j];\n\t\t...\n\t}\n\nTo fix this we should validate \"EALIST_SIZE(ea_buf->xattr)\"\
  \nbefore it is utilised.\n\nReported-by: syzbot <syzbot+4e6e7e4279d046613bc5@syzkaller.appspotmail.com>\n\
  Tested-by: syzbot <syzbot+4e6e7e4279d046613bc5@syzkaller.appspotmail.com>\nCloses:\
  \ https://syzkaller.appspot.com/bug?extid=4e6e7e4279d046613bc5\nFixes: d9f9d96136cb\
  \ (\"jfs: xattr: check invalid xattr size more strictly\")\nCc: stable@vger.kernel.org\n\
  Signed-off-by: Qasim Ijaz <qasdev00@gmail.com>\nSigned-off-by: Dave Kleikamp <dave.kleikamp@oracle.com>\n"
submodule:
- fs/jfs
hunk_count: 1
covered_count: 1
