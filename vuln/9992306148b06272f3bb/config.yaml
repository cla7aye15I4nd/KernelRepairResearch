id: 9992306148b06272f3bb
bug_link: https://syzkaller.appspot.com/bug?extid=9992306148b06272f3bb
title: WARNING in emit_fiemap_extent
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: c7bb26b847e5b97814f522686068c5628e2b3646
fix_commit: a1a4a9ca77f143c00fce69c1239887ff8b813bec
datetime: '2024-02-29T22:34:04+01:00'
fix_commit_message: "btrfs: fix race between ordered extent completion and fiemap\n\
  \nFor fiemap we recently stopped locking the target extent range for the\nwhole\
  \ duration of the fiemap call, in order to avoid a deadlock in a\nscenario where\
  \ the fiemap buffer happens to be a memory mapped range of\nthe same file. This\
  \ use case is very unlikely to be useful in practice but\nit may be triggered by\
  \ fuzz testing (syzbot, etc).\n\nHowever by not locking the target extent range\
  \ for the whole duration of\nthe fiemap call we can race with an ordered extent.\
  \ This happens like\nthis:\n\n1) The fiemap task finishes processing a file extent\
  \ item that covers\n   the file range [512K, 1M[, and that file extent item is the\
  \ last item\n   in the leaf currently being processed;\n\n2) And ordered extent\
  \ for the file range [768K, 2M[, in COW mode,\n   completes (btrfs_finish_one_ordered())\
  \ and the file extent item\n   covering the range [512K, 1M[ is trimmed to cover\
  \ the range\n   [512K, 768K[ and then a new file extent item for the range [768K,\
  \ 2M[\n   is inserted in the inode's subvolume tree;\n\n3) The fiemap task calls\
  \ fiemap_next_leaf_item(), which then calls\n   btrfs_next_leaf() to find the next\
  \ leaf / item. This finds that the\n   the next key following the one we previously\
  \ processed (its type is\n   BTRFS_EXTENT_DATA_KEY and its offset is 512K), is the\
  \ key corresponding\n   to the new file extent item inserted by the ordered extent,\
  \ which has\n   a type of BTRFS_EXTENT_DATA_KEY and an offset of 768K;\n\n4) Later\
  \ the fiemap code ends up at emit_fiemap_extent() and triggers\n   the warning:\n\
  \n      if (cache->offset + cache->len > offset) {\n               WARN_ON(1);\n\
  \               return -EINVAL;\n      }\n\n   Since we get 1M > 768K, because the\
  \ previously emitted entry for the\n   old extent covering the file range [512K,\
  \ 1M[ ends at an offset that\n   is greater than the new extent's start offset (768K).\
  \ This makes fiemap\n   fail with -EINVAL besides triggering the warning that produces\
  \ a stack\n   trace like the following:\n\n     [1621.677651] ------------[ cut\
  \ here ]------------\n     [1621.677656] WARNING: CPU: 1 PID: 204366 at fs/btrfs/extent_io.c:2492\
  \ emit_fiemap_extent+0x84/0x90 [btrfs]\n     [1621.677899] Modules linked in: btrfs\
  \ blake2b_generic (...)\n     [1621.677951] CPU: 1 PID: 204366 Comm: pool Not tainted\
  \ 6.8.0-rc5-btrfs-next-151+ #1\n     [1621.677954] Hardware name: QEMU Standard\
  \ PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014\n\
  \     [1621.677956] RIP: 0010:emit_fiemap_extent+0x84/0x90 [btrfs]\n     [1621.678033]\
  \ Code: 2b 4c 89 63 (...)\n     [1621.678035] RSP: 0018:ffffab16089ffd20 EFLAGS:\
  \ 00010206\n     [1621.678037] RAX: 00000000004fa000 RBX: ffffab16089ffe08 RCX:\
  \ 0000000000009000\n     [1621.678039] RDX: 00000000004f9000 RSI: 00000000004f1000\
  \ RDI: ffffab16089ffe90\n     [1621.678040] RBP: 00000000004f9000 R08: 0000000000001000\
  \ R09: 0000000000000000\n     [1621.678041] R10: 0000000000000000 R11: 0000000000001000\
  \ R12: 0000000041d78000\n     [1621.678043] R13: 0000000000001000 R14: 0000000000000000\
  \ R15: ffff9434f0b17850\n     [1621.678044] FS:  00007fa6e20006c0(0000) GS:ffff943bdfa40000(0000)\
  \ knlGS:0000000000000000\n     [1621.678046] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n\
  \     [1621.678048] CR2: 00007fa6b0801000 CR3: 000000012d404002 CR4: 0000000000370ef0\n\
  \     [1621.678053] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n\
  \     [1621.678055] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n\
  \     [1621.678056] Call Trace:\n     [1621.678074]  <TASK>\n     [1621.678076]\
  \  ? __warn+0x80/0x130\n     [1621.678082]  ? emit_fiemap_extent+0x84/0x90 [btrfs]\n\
  \     [1621.678159]  ? report_bug+0x1f4/0x200\n     [1621.678164]  ? handle_bug+0x42/0x70\n\
  \     [1621.678167]  ? exc_invalid_op+0x14/0x70\n     [1621.678170]  ? asm_exc_invalid_op+0x16/0x20\n\
  \     [1621.678178]  ? emit_fiemap_extent+0x84/0x90 [btrfs]\n     [1621.678253]\
  \  extent_fiemap+0x766/0xa30 [btrfs]\n     [1621.678339]  btrfs_fiemap+0x45/0x80\
  \ [btrfs]\n     [1621.678420]  do_vfs_ioctl+0x1e4/0x870\n     [1621.678431]  __x64_sys_ioctl+0x6a/0xc0\n\
  \     [1621.678434]  do_syscall_64+0x52/0x120\n     [1621.678445]  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n\
  \nThere's also another case where before calling btrfs_next_leaf() we are\nprocessing\
  \ a hole or a prealloc extent and we had several delalloc ranges\nwithin that hole\
  \ or prealloc extent. In that case if the ordered extents\ncomplete before we find\
  \ the next key, we may end up finding an extent item\nwith an offset smaller than\
  \ (or equals to) the offset in cache->offset.\n\nSo fix this by changing emit_fiemap_extent()\
  \ to address these three\nscenarios like this:\n\n1) For the first case, steps listed\
  \ above, adjust the length of the\n   previously cached extent so that it does not\
  \ overlap with the current\n   extent, emit the previous one and cache the current\
  \ file extent item;\n\n2) For the second case where he had a hole or prealloc extent\
  \ with\n   multiple delalloc ranges inside the hole or prealloc extent's range,\n\
  \   and the current file extent item has an offset that matches the offset\n   in\
  \ the fiemap cache, just discard what we have in the fiemap cache and\n   assign\
  \ the current file extent item to the cache, since it's more up\n   to date;\n\n\
  3) For the third case where he had a hole or prealloc extent with\n   multiple delalloc\
  \ ranges inside the hole or prealloc extent's range\n   and the offset of the file\
  \ extent item we just found is smaller than\n   what we have in the cache, just\
  \ skip the current file extent item\n   if its range end at or behind the cached\
  \ extent's end, because we may\n   have emitted (to the fiemap user space buffer)\
  \ delalloc ranges that\n   overlap with the current file extent item's range. If\
  \ the file extent\n   item's range goes beyond the end offset of the cached extent,\
  \ just\n   emit the cached extent and cache a subrange of the file extent item,\n\
  \   that goes from the end offset of the cached extent to the end offset\n   of\
  \ the file extent item.\n\nDealing with those cases in those ways makes everything\
  \ consistent by\nreflecting the current state of file extent items in the btree\
  \ and\nwithout emitting extents that have overlapping ranges (which would be\nconfusing\
  \ and violating expectations).\n\nThis issue could be triggered often with test\
  \ case generic/561, and was\nalso hit and reported by Wang Yugui.\n\nReported-by:\
  \ Wang Yugui <wangyugui@e16-tech.com>\nLink: https://lore.kernel.org/linux-btrfs/20240223104619.701F.409509F4@e16-tech.com/\n\
  Fixes: b0ad381fa769 (\"btrfs: fix deadlock with fiemap and extent locking\")\nReviewed-by:\
  \ Josef Bacik <josef@toxicpanda.com>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\n\
  Signed-off-by: David Sterba <dsterba@suse.com>\n"
submodule:
- fs/btrfs
hunk_count: 3
covered_count: 3
