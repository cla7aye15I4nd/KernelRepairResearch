id: b3b63b6bff456bd95294
bug_link: https://syzkaller.appspot.com/bug?extid=b3b63b6bff456bd95294
title: 'INFO: task can''t die in connmark_exit_net'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 6ea9309acc2840f8f3fd4d9706f228af6fc45700
fix_commit: d349f997686887906b1183b5be96933c5452362a
datetime: '2021-01-18T20:13:55-08:00'
fix_commit_message: "net_sched: fix RTNL deadlock again caused by request_module()\n\
  \ntcf_action_init_1() loads tc action modules automatically with\nrequest_module()\
  \ after parsing the tc action names, and it drops RTNL\nlock and re-holds it before\
  \ and after request_module(). This causes a\nlot of troubles, as discovered by syzbot,\
  \ because we can be in the\nmiddle of batch initializations when we create an array\
  \ of tc actions.\n\nOne of the problem is deadlock:\n\nCPU 0\t\t\t\t\tCPU 1\nrtnl_lock();\n\
  for (...) {\n  tcf_action_init_1();\n    -> rtnl_unlock();\n    -> request_module();\n\
  \t\t\t\trtnl_lock();\n\t\t\t\tfor (...) {\n\t\t\t\t  tcf_action_init_1();\n\t\t\t\
  \t    -> tcf_idr_check_alloc();\n\t\t\t\t   // Insert one action into idr,\n\t\t\
  \t\t   // but it is not committed until\n\t\t\t\t   // tcf_idr_insert_many(), then\
  \ drop\n\t\t\t\t   // the RTNL lock in the _next_\n\t\t\t\t   // iteration\n\t\t\
  \t\t   -> rtnl_unlock();\n    -> rtnl_lock();\n    -> a_o->init();\n      -> tcf_idr_check_alloc();\n\
  \      // Now waiting for the same index\n      // to be committed\n\t\t\t\t   \
  \ -> request_module();\n\t\t\t\t    -> rtnl_lock()\n\t\t\t\t    // Now waiting for\
  \ RTNL lock\n\t\t\t\t}\n\t\t\t\trtnl_unlock();\n}\nrtnl_unlock();\n\nThis is not\
  \ easy to solve, we can move the request_module() before\nthis loop and pre-load\
  \ all the modules we need for this netlink\nmessage and then do the rest initializations.\
  \ So the loop breaks down\nto two now:\n\n        for (i = 1; i <= TCA_ACT_MAX_PRIO\
  \ && tb[i]; i++) {\n                struct tc_action_ops *a_o;\n\n             \
  \   a_o = tc_action_load_ops(name, tb[i]...);\n                ops[i - 1] = a_o;\n\
  \        }\n\n        for (i = 1; i <= TCA_ACT_MAX_PRIO && tb[i]; i++) {\n     \
  \           act = tcf_action_init_1(ops[i - 1]...);\n        }\n\nAlthough this\
  \ looks serious, it only has been reported by syzbot, so it\nseems hard to trigger\
  \ this by humans. And given the size of this patch,\nI'd suggest to make it to net-next\
  \ and not to backport to stable.\n\nThis patch has been tested by syzbot and tested\
  \ with tdc.py by me.\n\nFixes: 0fedc63fadf0 (\"net_sched: commit action insertions\
  \ together\")\nReported-and-tested-by: syzbot+82752bc5331601cf4899@syzkaller.appspotmail.com\n\
  Reported-and-tested-by: syzbot+b3b63b6bff456bd95294@syzkaller.appspotmail.com\n\
  Reported-by: syzbot+ba67b12b1ca729912834@syzkaller.appspotmail.com\nCc: Jiri Pirko\
  \ <jiri@resnulli.us>\nSigned-off-by: Cong Wang <cong.wang@bytedance.com>\nTested-by:\
  \ Jamal Hadi Salim <jhs@mojatatu.com>\nAcked-by: Jamal Hadi Salim <jhs@mojatatu.com>\n\
  Link: https://lore.kernel.org/r/20210117005657.14810-1-xiyou.wangcong@gmail.com\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n"
submodule:
- include/net
- net/sched
hunk_count: 9
covered_count: 1
