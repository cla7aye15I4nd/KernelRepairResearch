id: 4998f18bcd5fc7e40c8b
bug_link: https://syzkaller.appspot.com/bug?extid=4998f18bcd5fc7e40c8b
title: kernel BUG in ext4_mb_use_inode_pa
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: d412df530f77d0f61c41b83f925997452fc3944c
fix_commit: 4bb26f2885ac6930984ee451b952c5a6042f2c0e
datetime: '2022-09-29T10:38:41-04:00'
fix_commit_message: "ext4: avoid crash when inline data creation follows DIO write\n\
  \nWhen inode is created and written to using direct IO, there is nothing\nto clear\
  \ the EXT4_STATE_MAY_INLINE_DATA flag. Thus when inode gets\ntruncated later to\
  \ say 1 byte and written using normal write, we will\ntry to store the data as inline\
  \ data. This confuses the code later\nbecause the inode now has both normal block\
  \ and inline data allocated\nand the confusion manifests for example as:\n\nkernel\
  \ BUG at fs/ext4/inode.c:2721!\ninvalid opcode: 0000 [#1] PREEMPT SMP KASAN\nCPU:\
  \ 0 PID: 359 Comm: repro Not tainted 5.19.0-rc8-00001-g31ba1e3b8305-dirty #15\n\
  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-1.fc36 04/01/2014\n\
  RIP: 0010:ext4_writepages+0x363d/0x3660\nRSP: 0018:ffffc90000ccf260 EFLAGS: 00010293\n\
  RAX: ffffffff81e1abcd RBX: 0000008000000000 RCX: ffff88810842a180\nRDX: 0000000000000000\
  \ RSI: 0000008000000000 RDI: 0000000000000000\nRBP: ffffc90000ccf650 R08: ffffffff81e17d58\
  \ R09: ffffed10222c680b\nR10: dfffe910222c680c R11: 1ffff110222c680a R12: ffff888111634128\n\
  R13: ffffc90000ccf880 R14: 0000008410000000 R15: 0000000000000001\nFS:  00007f72635d2640(0000)\
  \ GS:ffff88811b000000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000\
  \ CR0: 0000000080050033\nCR2: 0000565243379180 CR3: 000000010aa74000 CR4: 0000000000150eb0\n\
  Call Trace:\n <TASK>\n do_writepages+0x397/0x640\n filemap_fdatawrite_wbc+0x151/0x1b0\n\
  \ file_write_and_wait_range+0x1c9/0x2b0\n ext4_sync_file+0x19e/0xa00\n vfs_fsync_range+0x17b/0x190\n\
  \ ext4_buffered_write_iter+0x488/0x530\n ext4_file_write_iter+0x449/0x1b90\n vfs_write+0xbcd/0xf40\n\
  \ ksys_write+0x198/0x2c0\n __x64_sys_write+0x7b/0x90\n do_syscall_64+0x3d/0x90\n\
  \ entry_SYSCALL_64_after_hwframe+0x63/0xcd\n </TASK>\n\nFix the problem by clearing\
  \ EXT4_STATE_MAY_INLINE_DATA when we are doing\ndirect IO write to a file.\n\nCc:\
  \ stable@kernel.org\nReported-by: Tadeusz Struk <tadeusz.struk@linaro.org>\nReported-by:\
  \ syzbot+bd13648a53ed6933ca49@syzkaller.appspotmail.com\nLink: https://syzkaller.appspot.com/bug?id=a1e89d09bbbcbd5c4cb45db230ee28c822953984\n\
  Signed-off-by: Jan Kara <jack@suse.cz>\nReviewed-by: Lukas Czerner <lczerner@redhat.com>\n\
  Tested-by: Tadeusz Struk<tadeusz.struk@linaro.org>\nLink: https://lore.kernel.org/r/20220727155753.13969-1-jack@suse.cz\n\
  Signed-off-by: Theodore Ts'o <tytso@mit.edu>\n"
submodule:
- fs/ext4
hunk_count: 1
covered_count: 1
