id: 0165480d4ef07360eeda
bug_link: https://syzkaller.appspot.com/bug?extid=0165480d4ef07360eeda
title: 'KASAN: use-after-free Write in xfrm_hash_rebuild'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 52e63a4eabcf6ed9add47aefe86ada31e12e6d39
fix_commit: fd709721352dd5239056eacaded00f2244e6ef58
datetime: '2019-07-03T10:50:35+02:00'
fix_commit_message: "xfrm: policy: fix bydst hlist corruption on hash rebuild\n\n\
  syzbot reported following spat:\n\nBUG: KASAN: use-after-free in __write_once_size\
  \ include/linux/compiler.h:221\nBUG: KASAN: use-after-free in hlist_del_rcu include/linux/rculist.h:455\n\
  BUG: KASAN: use-after-free in xfrm_hash_rebuild+0xa0d/0x1000 net/xfrm/xfrm_policy.c:1318\n\
  Write of size 8 at addr ffff888095e79c00 by task kworker/1:3/8066\nWorkqueue: events\
  \ xfrm_hash_rebuild\nCall Trace:\n __write_once_size include/linux/compiler.h:221\
  \ [inline]\n hlist_del_rcu include/linux/rculist.h:455 [inline]\n xfrm_hash_rebuild+0xa0d/0x1000\
  \ net/xfrm/xfrm_policy.c:1318\n process_one_work+0x814/0x1130 kernel/workqueue.c:2269\n\
  Allocated by task 8064:\n __kmalloc+0x23c/0x310 mm/slab.c:3669\n kzalloc include/linux/slab.h:742\
  \ [inline]\n xfrm_hash_alloc+0x38/0xe0 net/xfrm/xfrm_hash.c:21\n xfrm_policy_init\
  \ net/xfrm/xfrm_policy.c:4036 [inline]\n xfrm_net_init+0x269/0xd60 net/xfrm/xfrm_policy.c:4120\n\
  \ ops_init+0x336/0x420 net/core/net_namespace.c:130\n setup_net+0x212/0x690 net/core/net_namespace.c:316\n\
  \nThe faulting address is the address of the old chain head,\nfree'd by xfrm_hash_resize().\n\
  \nIn xfrm_hash_rehash(), chain heads get re-initialized without\nany hlist_del_rcu:\n\
  \n for (i = hmask; i >= 0; i--)\n    INIT_HLIST_HEAD(odst + i);\n\nThen, hlist_del_rcu()\
  \ gets called on the about to-be-reinserted policy\nwhen iterating the per-net list\
  \ of policies.\n\nhlist_del_rcu() will then make chain->first be nonzero again:\n\
  \nstatic inline void __hlist_del(struct hlist_node *n)\n{\n   struct hlist_node\
  \ *next = n->next;   // address of next element in list\n   struct hlist_node **pprev\
  \ = n->pprev;// location of previous elem, this\n                              \
  \          // can point at chain->first\n        WRITE_ONCE(*pprev, next);     \
  \  // chain->first points to next elem\n        if (next)\n                next->pprev\
  \ = pprev;\n\nThen, when we walk chainlist to find insertion point, we may find\
  \ a\nnon-empty list even though we're supposedly reinserting the first\npolicy to\
  \ an empty chain.\n\nTo fix this first unlink all exact and inexact policies instead\
  \ of\nzeroing the list heads.\n\nAdd the commands equivalent to the syzbot reproducer\
  \ to xfrm_policy.sh,\nwithout fix KASAN catches the corruption as it happens, SLUB\
  \ poisoning\ndetects it a bit later.\n\nReported-by: syzbot+0165480d4ef07360eeda@syzkaller.appspotmail.com\n\
  Fixes: 1548bc4e0512 (\"xfrm: policy: delete inexact policies from inexact list on\
  \ hash rebuild\")\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by:\
  \ Steffen Klassert <steffen.klassert@secunet.com>\n"
submodule:
- net/xfrm
- tools/testing/selftests/net
hunk_count: 4
covered_count: 2
