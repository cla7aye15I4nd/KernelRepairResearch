id: 278279efdd2730dd14bf
bug_link: https://syzkaller.appspot.com/bug?extid=278279efdd2730dd14bf
title: general protection fault in skb_unlink
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 280c0f7cd0aa4d190619b18243110e052a90775c
fix_commit: 5121197ecc5db58c07da95eb1ff82b98b121a221
datetime: '2022-11-15T12:42:26+01:00'
fix_commit_message: 'kcm: close race conditions on sk_receive_queue


  sk->sk_receive_queue is protected by skb queue lock, but for KCM

  sockets its RX path takes mux->rx_lock to protect more than just

  skb queue. However, kcm_recvmsg() still only grabs the skb queue

  lock, so race conditions still exist.


  We can teach kcm_recvmsg() to grab mux->rx_lock too but this would

  introduce a potential performance regression as struct kcm_mux can

  be shared by multiple KCM sockets.


  So we have to enforce skb queue lock in requeue_rx_msgs() and handle

  skb peek case carefully in kcm_wait_data(). Fortunately,

  skb_recv_datagram() already handles it nicely and is widely used by

  other sockets, we can just switch to skb_recv_datagram() after

  getting rid of the unnecessary sock lock in kcm_recvmsg() and

  kcm_splice_read(). Side note: SOCK_DONE is not used by KCM sockets,

  so it is safe to get rid of this check too.


  I ran the original syzbot reproducer for 30 min without seeing any

  issue.


  Fixes: ab7ac4eb9832 ("kcm: Kernel Connection Multiplexor module")

  Reported-by: syzbot+278279efdd2730dd14bf@syzkaller.appspotmail.com

  Reported-by: shaozhengchao <shaozhengchao@huawei.com>

  Cc: Paolo Abeni <pabeni@redhat.com>

  Cc: Tom Herbert <tom@herbertland.com>

  Signed-off-by: Cong Wang <cong.wang@bytedance.com>

  Link: https://lore.kernel.org/r/20221114005119.597905-1-xiyou.wangcong@gmail.com

  Signed-off-by: Paolo Abeni <pabeni@redhat.com>

  '
submodule:
- net/kcm
hunk_count: 6
covered_count: 4
