id: 67ba3c42bcbb4665d3ad
bug_link: https://syzkaller.appspot.com/bug?extid=67ba3c42bcbb4665d3ad
title: kernel BUG in clear_inode
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 0ac3396ea4a2ab1c80ea560b4dd22f2a3c13a7e9
fix_commit: 88b1afbf0f6b221f6c5bb66cc80cd3b38d696687
datetime: '2024-08-30T08:22:39+02:00'
fix_commit_message: "vfs: fix race between evice_inodes() and find_inode()&iput()\n\
  \nHi, all\n\nRecently I noticed a bug[1] in btrfs, after digged it into\nand I believe\
  \ it'a race in vfs.\n\nLet's assume there's a inode (ie ino 261) with i_count 1\
  \ is\ncalled by iput(), and there's a concurrent thread calling\ngeneric_shutdown_super().\n\
  \ncpu0:                              cpu1:\niput() // i_count is 1\n  ->spin_lock(inode)\n\
  \  ->dec i_count to 0\n  ->iput_final()                    generic_shutdown_super()\n\
  \    ->__inode_add_lru()               ->evict_inodes()\n      // cause some reason[2]\
  \           ->if (atomic_read(inode->i_count)) continue;\n      // return before\
  \                  // inode 261 passed the above check\n      // list_lru_add_obj()\
  \             // and then schedule out\n   ->spin_unlock()\n// note here: the inode\
  \ 261\n// was still at sb list and hash list,\n// and I_FREEING|I_WILL_FREE was\
  \ not been set\n\nbtrfs_iget()\n  // after some function calls\n  ->find_inode()\n\
  \    // found the above inode 261\n    ->spin_lock(inode)\n   // check I_FREEING|I_WILL_FREE\n\
  \   // and passed\n      ->__iget()\n    ->spin_unlock(inode)                //\
  \ schedule back\n                                        ->spin_lock(inode)\n  \
  \                                      // check (I_NEW|I_FREEING|I_WILL_FREE) flags,\n\
  \                                        // passed and set I_FREEING\niput()   \
  \                               ->spin_unlock(inode)\n  ->spin_lock(inode)\t\t\t\
  \  ->evict()\n  // dec i_count to 0\n  ->iput_final()\n    ->spin_unlock()\n   \
  \ ->evict()\n\nNow, we have two threads simultaneously evicting\nthe same inode,\
  \ which may trigger the BUG(inode->i_state & I_CLEAR)\nstatement both within clear_inode()\
  \ and iput().\n\nTo fix the bug, recheck the inode->i_count after holding i_lock.\n\
  Because in the most scenarios, the first check is valid, and\nthe overhead of spin_lock()\
  \ can be reduced.\n\nIf there is any misunderstanding, please let me know, thanks.\n\
  \n[1]: https://lore.kernel.org/linux-btrfs/000000000000eabe1d0619c48986@google.com/\n\
  [2]: The reason might be 1. SB_ACTIVE was removed or 2. mapping_shrinkable()\nreturn\
  \ false when I reproduced the bug.\n\nReported-by: syzbot+67ba3c42bcbb4665d3ad@syzkaller.appspotmail.com\n\
  Closes: https://syzkaller.appspot.com/bug?extid=67ba3c42bcbb4665d3ad\nCC: stable@vger.kernel.org\n\
  Fixes: 63997e98a3be (\"split invalidate_inodes()\")\nSigned-off-by: Julian Sun <sunjunchao2870@gmail.com>\n\
  Link: https://lore.kernel.org/r/20240823130730.658881-1-sunjunchao2870@gmail.com\n\
  Reviewed-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Christian Brauner <brauner@kernel.org>\n"
submodule:
- fs
hunk_count: 1
covered_count: 1
