id: 34fe5894623c4ab1b379
bug_link: https://syzkaller.appspot.com/bug?extid=34fe5894623c4ab1b379
title: possible deadlock in br_ioctl_call
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 4167a960574fcadc9067f4280951a35b8c021c68
fix_commit: 893b195875340cb44b54c9db99e708145f1210e8
datetime: '2021-08-05T11:36:59+01:00'
fix_commit_message: 'net: bridge: fix ioctl locking


  Before commit ad2f99aedf8f ("net: bridge: move bridge ioctls out of

  .ndo_do_ioctl") the bridge ioctl calls were divided in two parts:

  one was deviceless called by sock_ioctl and didn''t expect rtnl to be held,

  the other was with a device called by dev_ifsioc() and expected rtnl to be

  held. After the commit above they were united in a single ioctl stub, but

  it didn''t take care of the locking expectations.

  For sock_ioctl now we acquire  (1) br_ioctl_mutex, (2) rtnl

  and for dev_ifsioc we acquire  (1) rtnl,           (2) br_ioctl_mutex


  The fix is to get a refcnt on the netdev for dev_ifsioc calls and drop rtnl

  then to reacquire it in the bridge ioctl stub after br_ioctl_mutex has

  been acquired. That will avoid playing locking games and make the rules

  straight-forward: we always take br_ioctl_mutex first, and then rtnl.


  Reported-by: syzbot+34fe5894623c4ab1b379@syzkaller.appspotmail.com

  Fixes: ad2f99aedf8f ("net: bridge: move bridge ioctls out of .ndo_do_ioctl")

  Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>

  Signed-off-by: David S. Miller <davem@davemloft.net>

  '
submodule:
- net/bridge
- net/core
hunk_count: 5
covered_count: 5
