id: dfcc5f4da15868df7d4d
bug_link: https://syzkaller.appspot.com/bug?extid=dfcc5f4da15868df7d4d
title: inconsistent lock state in kmem_cache_alloc
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 3e4cb6ebbb2bad201c1186bc0b7e8cf41dd7f7e6
fix_commit: b000145e9907809406d8164c3b2b8861d95aecd1
datetime: '2022-09-29T11:00:41-06:00'
fix_commit_message: "io_uring/rw: defer fsnotify calls to task context\n\nWe can't\
  \ call these off the kiocb completion as that might be off\nsoft/hard irq context.\
  \ Defer the calls to when we process the\ntask_work for this request. That avoids\
  \ valid complaints like:\n\nstack backtrace:\nCPU: 1 PID: 0 Comm: swapper/1 Not\
  \ tainted 6.0.0-rc6-syzkaller-00321-g105a36f3694e #0\nHardware name: Google Google\
  \ Compute Engine/Google Compute Engine, BIOS Google 08/26/2022\nCall Trace:\n <IRQ>\n\
  \ __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n\
  \ print_usage_bug kernel/locking/lockdep.c:3961 [inline]\n valid_state kernel/locking/lockdep.c:3973\
  \ [inline]\n mark_lock_irq kernel/locking/lockdep.c:4176 [inline]\n mark_lock.part.0.cold+0x18/0xd8\
  \ kernel/locking/lockdep.c:4632\n mark_lock kernel/locking/lockdep.c:4596 [inline]\n\
  \ mark_usage kernel/locking/lockdep.c:4527 [inline]\n __lock_acquire+0x11d9/0x56d0\
  \ kernel/locking/lockdep.c:5007\n lock_acquire kernel/locking/lockdep.c:5666 [inline]\n\
  \ lock_acquire+0x1ab/0x570 kernel/locking/lockdep.c:5631\n __fs_reclaim_acquire\
  \ mm/page_alloc.c:4674 [inline]\n fs_reclaim_acquire+0x115/0x160 mm/page_alloc.c:4688\n\
  \ might_alloc include/linux/sched/mm.h:271 [inline]\n slab_pre_alloc_hook mm/slab.h:700\
  \ [inline]\n slab_alloc mm/slab.c:3278 [inline]\n __kmem_cache_alloc_lru mm/slab.c:3471\
  \ [inline]\n kmem_cache_alloc+0x39/0x520 mm/slab.c:3491\n fanotify_alloc_fid_event\
  \ fs/notify/fanotify/fanotify.c:580 [inline]\n fanotify_alloc_event fs/notify/fanotify/fanotify.c:813\
  \ [inline]\n fanotify_handle_event+0x1130/0x3f40 fs/notify/fanotify/fanotify.c:948\n\
  \ send_to_group fs/notify/fsnotify.c:360 [inline]\n fsnotify+0xafb/0x1680 fs/notify/fsnotify.c:570\n\
  \ __fsnotify_parent+0x62f/0xa60 fs/notify/fsnotify.c:230\n fsnotify_parent include/linux/fsnotify.h:77\
  \ [inline]\n fsnotify_file include/linux/fsnotify.h:99 [inline]\n fsnotify_access\
  \ include/linux/fsnotify.h:309 [inline]\n __io_complete_rw_common+0x485/0x720 io_uring/rw.c:195\n\
  \ io_complete_rw+0x1a/0x1f0 io_uring/rw.c:228\n iomap_dio_complete_work fs/iomap/direct-io.c:144\
  \ [inline]\n iomap_dio_bio_end_io+0x438/0x5e0 fs/iomap/direct-io.c:178\n bio_endio+0x5f9/0x780\
  \ block/bio.c:1564\n req_bio_endio block/blk-mq.c:695 [inline]\n blk_update_request+0x3fc/0x1300\
  \ block/blk-mq.c:825\n scsi_end_request+0x7a/0x9a0 drivers/scsi/scsi_lib.c:541\n\
  \ scsi_io_completion+0x173/0x1f70 drivers/scsi/scsi_lib.c:971\n scsi_complete+0x122/0x3b0\
  \ drivers/scsi/scsi_lib.c:1438\n blk_complete_reqs+0xad/0xe0 block/blk-mq.c:1022\n\
  \ __do_softirq+0x1d3/0x9c6 kernel/softirq.c:571\n invoke_softirq kernel/softirq.c:445\
  \ [inline]\n __irq_exit_rcu+0x123/0x180 kernel/softirq.c:650\n irq_exit_rcu+0x5/0x20\
  \ kernel/softirq.c:662\n common_interrupt+0xa9/0xc0 arch/x86/kernel/irq.c:240\n\n\
  Fixes: f63cf5192fe3 (\"io_uring: ensure that fsnotify is always called\")\nLink:\
  \ https://lore.kernel.org/all/20220929135627.ykivmdks2w5vzrwg@quack3/\nReported-by:\
  \ syzbot+dfcc5f4da15868df7d4d@syzkaller.appspotmail.com\nReported-by: Jan Kara <jack@suse.cz>\n\
  Signed-off-by: Jens Axboe <axboe@kernel.dk>\n"
submodule:
- io_uring
hunk_count: 3
covered_count: 3
