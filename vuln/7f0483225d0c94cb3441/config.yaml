id: 7f0483225d0c94cb3441
bug_link: https://syzkaller.appspot.com/bug?extid=7f0483225d0c94cb3441
title: 'WARNING: bad unlock balance in rxrpc_do_sendmsg'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 0cf731f9ebb5bf6f252055bebf4463a5c0bd490b
fix_commit: b0f571ecd7943423c25947439045f0d352ca3dbf
datetime: '2022-08-25T12:39:40-07:00'
fix_commit_message: "rxrpc: Fix locking in rxrpc's sendmsg\n\nFix three bugs in the\
  \ rxrpc's sendmsg implementation:\n\n (1) rxrpc_new_client_call() should release\
  \ the socket lock when returning\n     an error from rxrpc_get_call_slot().\n\n\
  \ (2) rxrpc_wait_for_tx_window_intr() will return without the call mutex\n     held\
  \ in the event that we're interrupted by a signal whilst waiting\n     for tx space\
  \ on the socket or relocking the call mutex afterwards.\n\n     Fix this by: (a)\
  \ moving the unlock/lock of the call mutex up to\n     rxrpc_send_data() such that\
  \ the lock is not held around all of\n     rxrpc_wait_for_tx_window*() and (b) indicating\
  \ to higher callers\n     whether we're return with the lock dropped.  Note that\
  \ this means\n     recvmsg() will not block on this call whilst we're waiting.\n\
  \n (3) After dropping and regaining the call mutex, rxrpc_send_data() needs\n  \
  \   to go and recheck the state of the tx_pending buffer and the\n     tx_total_len\
  \ check in case we raced with another sendmsg() on the same\n     call.\n\nThinking\
  \ on this some more, it might make sense to have different locks for\nsendmsg()\
  \ and recvmsg().  There's probably no need to make recvmsg() wait\nfor sendmsg().\
  \  It does mean that recvmsg() can return MSG_EOR indicating\nthat a call is dead\
  \ before a sendmsg() to that call returns - but that can\ncurrently happen anyway.\n\
  \nWithout fix (2), something like the following can be induced:\n\n\tWARNING: bad\
  \ unlock balance detected!\n\t5.16.0-rc6-syzkaller #0 Not tainted\n\t-------------------------------------\n\
  \tsyz-executor011/3597 is trying to release lock (&call->user_mutex) at:\n\t[<ffffffff885163a3>]\
  \ rxrpc_do_sendmsg+0xc13/0x1350 net/rxrpc/sendmsg.c:748\n\tbut there are no more\
  \ locks to release!\n\n\tother info that might help us debug this:\n\tno locks held\
  \ by syz-executor011/3597.\n\t...\n\tCall Trace:\n\t <TASK>\n\t __dump_stack lib/dump_stack.c:88\
  \ [inline]\n\t dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106\n\t print_unlock_imbalance_bug\
  \ include/trace/events/lock.h:58 [inline]\n\t __lock_release kernel/locking/lockdep.c:5306\
  \ [inline]\n\t lock_release.cold+0x49/0x4e kernel/locking/lockdep.c:5657\n\t __mutex_unlock_slowpath+0x99/0x5e0\
  \ kernel/locking/mutex.c:900\n\t rxrpc_do_sendmsg+0xc13/0x1350 net/rxrpc/sendmsg.c:748\n\
  \t rxrpc_sendmsg+0x420/0x630 net/rxrpc/af_rxrpc.c:561\n\t sock_sendmsg_nosec net/socket.c:704\
  \ [inline]\n\t sock_sendmsg+0xcf/0x120 net/socket.c:724\n\t ____sys_sendmsg+0x6e8/0x810\
  \ net/socket.c:2409\n\t ___sys_sendmsg+0xf3/0x170 net/socket.c:2463\n\t __sys_sendmsg+0xe5/0x1b0\
  \ net/socket.c:2492\n\t do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n\t do_syscall_64+0x35/0xb0\
  \ arch/x86/entry/common.c:80\n\t entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n[Thanks\
  \ to Hawkins Jiawei and Khalid Masum for their attempts to fix this]\n\nFixes: bc5e3a546d55\
  \ (\"rxrpc: Use MSG_WAITALL to tell sendmsg() to temporarily ignore signals\")\n\
  Reported-by: syzbot+7f0483225d0c94cb3441@syzkaller.appspotmail.com\nSigned-off-by:\
  \ David Howells <dhowells@redhat.com>\nReviewed-by: Marc Dionne <marc.dionne@auristor.com>\n\
  Tested-by: syzbot+7f0483225d0c94cb3441@syzkaller.appspotmail.com\ncc: Hawkins Jiawei\
  \ <yin31149@gmail.com>\ncc: Khalid Masum <khalid.masum.92@gmail.com>\ncc: Dan Carpenter\
  \ <dan.carpenter@oracle.com>\ncc: linux-afs@lists.infradead.org\nLink: https://lore.kernel.org/r/166135894583.600315.7170979436768124075.stgit@warthog.procyon.org.uk\n\
  Signed-off-by: Jakub Kicinski <kuba@kernel.org>\n"
submodule:
- net/rxrpc
hunk_count: 10
covered_count: 4
