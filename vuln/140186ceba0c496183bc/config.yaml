id: 140186ceba0c496183bc
bug_link: https://syzkaller.appspot.com/bug?extid=140186ceba0c496183bc
title: 'BUG: sleeping function called from invalid context in sk_psock_stop'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: fd75733da2f376c0c8c6513c3cb2ac227082ec5c
fix_commit: 697fb80a53642be624f5121b6ca9d66769c180e0
datetime: '2022-06-28T09:30:03+02:00'
fix_commit_message: "bpf: Fix sockmap calling sleepable function in teardown path\n\
  \nsyzbot reproduced the bug ...\n\n BUG: sleeping function called from invalid context\
  \ at kernel/workqueue.c:3010\n\n... with the following stack trace fragment ...\n\
  \n start_flush_work kernel/workqueue.c:3010 [inline]\n __flush_work+0x109/0xb10\
  \ kernel/workqueue.c:3074\n __cancel_work_timer+0x3f9/0x570 kernel/workqueue.c:3162\n\
  \ sk_psock_stop+0x4cb/0x630 net/core/skmsg.c:802\n sock_map_destroy+0x333/0x760\
  \ net/core/sock_map.c:1581\n inet_csk_destroy_sock+0x196/0x440 net/ipv4/inet_connection_sock.c:1130\n\
  \ __tcp_close+0xd5b/0x12b0 net/ipv4/tcp.c:2897\n tcp_close+0x29/0xc0 net/ipv4/tcp.c:2909\n\
  \n... introduced by d8616ee2affc. Do a quick trace of the code path and the\nbug\
  \ is obvious:\n\n   inet_csk_destroy_sock(sk)\n     sk_prot->destroy(sk);      <---\
  \ sock_map_destroy\n        sk_psock_stop(, true);   <--- true so cancel workqueue\n\
  \          cancel_work_sync()     <--- splat, because *_bh_disable()\n\nWe can not\
  \ call cancel_work_sync() from inside destroy path. So mark\nthe sk_psock_stop call\
  \ to skip this cancel_work_sync(). This will avoid\nthe BUG, but means we may run\
  \ sk_psock_backlog after or during the\ndestroy op. We zapped the ingress_skb queue\
  \ in sk_psock_stop (safe to\ndo with local_bh_disable) so its empty and the sk_psock_backlog\
  \ work\nitem will not find any pkts to process here. However, because we are\nnot\
  \ going to wait for it or clear its ->state its possible it kicks off\nor is already\
  \ running. This should be 'safe' up until psock drops its\nrefcnt to psock->sk.\
  \ The sock_put() that drops this reference is only\ndone at psock destroy time from\
  \ sk_psock_destroy(). This is done through\nworkqueue when sk_psock_drop() is called\
  \ on psock refnt reaches 0.\nAnd importantly sk_psock_destroy() does a cancel_work_sync().\
  \ So trivial\nfix works.\n\nI've had hit or miss luck reproducing this caught it\
  \ once or twice with\nthe provided reproducer when running with many runners. However,\
  \ syzkaller\nis very good at reproducing so relying on syzkaller to verify fix.\n\
  \nFixes: d8616ee2affc (\"bpf, sockmap: Fix sk->sk_forward_alloc warn_on in sk_stream_kill_queues\"\
  )\nReported-by: syzbot+140186ceba0c496183bc@syzkaller.appspotmail.com\nSuggested-by:\
  \ Hillf Danton <hdanton@sina.com>\nSigned-off-by: John Fastabend <john.fastabend@gmail.com>\n\
  Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>\nCc: Wang Yufen <wangyufen@huawei.com>\n\
  Link: https://lore.kernel.org/bpf/20220628035803.317876-1-john.fastabend@gmail.com\n"
submodule:
- net/core
hunk_count: 1
covered_count: 1
