id: 03beeb595f074db9cfd1
bug_link: https://syzkaller.appspot.com/bug?extid=03beeb595f074db9cfd1
title: 'INFO: task can''t die in io_sq_thread_stop'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 36f72fe2792c4304f1203a44a6a7178e49b447f7
fix_commit: 65b2b213484acd89a3c20dbb524e52a2f3793b78
datetime: '2020-12-09T12:04:01-07:00'
fix_commit_message: "io_uring: check kthread stopped flag when sq thread is unparked\n\
  \nsyzbot reports following issue:\nINFO: task syz-executor.2:12399 can't die for\
  \ more than 143 seconds.\ntask:syz-executor.2  state:D stack:28744 pid:12399 ppid:\
  \  8504 flags:0x00004004\nCall Trace:\n context_switch kernel/sched/core.c:3773\
  \ [inline]\n __schedule+0x893/0x2170 kernel/sched/core.c:4522\n schedule+0xcf/0x270\
  \ kernel/sched/core.c:4600\n schedule_timeout+0x1d8/0x250 kernel/time/timer.c:1847\n\
  \ do_wait_for_common kernel/sched/completion.c:85 [inline]\n __wait_for_common kernel/sched/completion.c:106\
  \ [inline]\n wait_for_common kernel/sched/completion.c:117 [inline]\n wait_for_completion+0x163/0x260\
  \ kernel/sched/completion.c:138\n kthread_stop+0x17a/0x720 kernel/kthread.c:596\n\
  \ io_put_sq_data fs/io_uring.c:7193 [inline]\n io_sq_thread_stop+0x452/0x570 fs/io_uring.c:7290\n\
  \ io_finish_async fs/io_uring.c:7297 [inline]\n io_sq_offload_create fs/io_uring.c:8015\
  \ [inline]\n io_uring_create fs/io_uring.c:9433 [inline]\n io_uring_setup+0x19b7/0x3730\
  \ fs/io_uring.c:9507\n do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\
  RIP: 0033:0x45deb9\nCode: Unable to access opcode bytes at RIP 0x45de8f.\nRSP: 002b:00007f174e51ac78\
  \ EFLAGS: 00000246 ORIG_RAX: 00000000000001a9\nRAX: ffffffffffffffda RBX: 0000000000008640\
  \ RCX: 000000000045deb9\nRDX: 0000000000000000 RSI: 0000000020000140 RDI: 00000000000050e5\n\
  RBP: 000000000118bf58 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000\
  \ R11: 0000000000000246 R12: 000000000118bf2c\nR13: 00007ffed9ca723f R14: 00007f174e51b9c0\
  \ R15: 000000000118bf2c\nINFO: task syz-executor.2:12399 blocked for more than 143\
  \ seconds.\n      Not tainted 5.10.0-rc3-next-20201110-syzkaller #0\n\"echo 0 >\
  \ /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n\nCurrently\
  \ we don't have a reproducer yet, but seems that there is a\nrace in current codes:\n\
  => io_put_sq_data\n      ctx_list is empty now.       |\n==> kthread_park(sqd->thread);\
  \     |\n                                   | T1: sq thread is parked now.\n==>\
  \ kthread_stop(sqd->thread);     |\n    KTHREAD_SHOULD_STOP is set now.|\n===> kthread_unpark(k);\
  \            |\n                                   | T2: sq thread is now unparkd,\
  \ run again.\n                                   |\n                           \
  \        | T3: sq thread is now preempted out.\n                               \
  \    |\n===> wake_up_process(k);           |\n                                 \
  \  |\n                                   | T4: Since sqd ctx_list is empty, needs_sched\
  \ will be true,\n                                   | then sq thread sets task state\
  \ to TASK_INTERRUPTIBLE,\n                                   | and schedule, now\
  \ sq thread will never be waken up.\n===> wait_for_completion           |\n\nI have\
  \ artificially used mdelay() to simulate above race, will get same\nstack like this\
  \ syzbot report, but to be honest, I'm not sure this code\nrace triggers syzbot\
  \ report.\n\nTo fix this possible code race, when sq thread is unparked, need to\
  \ check\nwhether sq thread has been stopped.\n\nReported-by: syzbot+03beeb595f074db9cfd1@syzkaller.appspotmail.com\n\
  Signed-off-by: Xiaoguang Wang <xiaoguang.wang@linux.alibaba.com>\nSigned-off-by:\
  \ Jens Axboe <axboe@kernel.dk>\n"
submodule:
- fs
hunk_count: 1
covered_count: 0
