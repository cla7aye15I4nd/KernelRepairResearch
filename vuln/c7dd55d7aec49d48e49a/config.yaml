id: c7dd55d7aec49d48e49a
bug_link: https://syzkaller.appspot.com/bug?extid=c7dd55d7aec49d48e49a
title: 'KASAN: use-after-free Read in sctp_id2assoc'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 9675931e6b65d160d16bcc9472c1acef15524def
fix_commit: b336decab22158937975293aea79396525f92bb3
datetime: '2018-10-17T22:11:14-07:00'
fix_commit_message: "sctp: fix race on sctp_id2asoc\n\nsyzbot reported an use-after-free\
  \ involving sctp_id2asoc.  Dmitry Vyukov\nhelped to root cause it and it is because\
  \ of reading the asoc after it\nwas freed:\n\n        CPU 1                    \
  \   CPU 2\n(working on socket 1)            (working on socket 2)\n\t          \
  \               sctp_association_destroy\nsctp_id2asoc\n   spin lock\n     grab\
  \ the asoc from idr\n   spin unlock\n                                   spin lock\n\
  \t\t\t\t     remove asoc from idr\n\t\t\t\t   spin unlock\n\t\t\t\t   free(asoc)\n\
  \   if asoc->base.sk != sk ... [*]\n\nThis can only be hit if trying to fetch asocs\
  \ from different sockets. As\nwe have a single IDR for all asocs, in all SCTP sockets,\
  \ their id is\nunique on the system. An application can try to send stuff on an\
  \ id\nthat matches on another socket, and the if in [*] will protect from such\n\
  usage. But it didn't consider that as that asoc may belong to another\nsocket, it\
  \ may be freed in parallel (read: under another socket lock).\n\nWe fix it by moving\
  \ the checks in [*] into the protected region. This\nfixes it because the asoc cannot\
  \ be freed while the lock is held.\n\nReported-by: syzbot+c7dd55d7aec49d48e49a@syzkaller.appspotmail.com\n\
  Acked-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Marcelo Ricardo Leitner\
  \ <marcelo.leitner@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by:\
  \ David S. Miller <davem@davemloft.net>\n"
submodule:
- net/sctp
hunk_count: 1
covered_count: 1
