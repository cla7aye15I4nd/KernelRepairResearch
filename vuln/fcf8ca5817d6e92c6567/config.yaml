id: fcf8ca5817d6e92c6567
bug_link: https://syzkaller.appspot.com/bug?extid=fcf8ca5817d6e92c6567
title: 'INFO: task hung in lock_sock_nested (3)'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 0eb484ee49c90581af87152df43a119cbe7a2e5f
fix_commit: d9fb8c507d42256034b457ec59347855bec9e569
datetime: '2020-10-08T17:24:04-07:00'
fix_commit_message: 'mptcp: fix infinite loop on recvmsg()/worker() race.


  If recvmsg() and the workqueue race to dequeue the data

  pending on some subflow, the current mapping for such

  subflow covers several skbs and some of them have not

  reached yet the received, either the worker or recvmsg()

  can find a subflow with the data_avail flag set - since

  the current mapping is valid and in sequence - but no

  skbs in the receive queue - since the other entity just

  processed them.


  The above will lead to an unbounded loop in __mptcp_move_skbs()

  and a subsequent hang of any task trying to acquiring the msk

  socket lock.


  This change addresses the issue stopping the __mptcp_move_skbs()

  loop as soon as we detect the above race (empty receive queue

  with data_avail set).


  Reported-and-tested-by: syzbot+fcf8ca5817d6e92c6567@syzkaller.appspotmail.com

  Fixes: ab174ad8ef76 ("mptcp: move ooo skbs into msk out of order queue.")

  Signed-off-by: Paolo Abeni <pabeni@redhat.com>

  Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

  Signed-off-by: Jakub Kicinski <kuba@kernel.org>

  '
submodule:
- net/mptcp
hunk_count: 1
covered_count: 1
