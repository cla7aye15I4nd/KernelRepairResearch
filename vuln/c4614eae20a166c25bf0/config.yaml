id: c4614eae20a166c25bf0
bug_link: https://syzkaller.appspot.com/bug?extid=c4614eae20a166c25bf0
title: kernel BUG in assertfail (2)
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: deccae40e4b30f98837e44225194d80c8baf2233
fix_commit: 745806fb4554f334e6406fa82b328562aa48f08f
datetime: '2023-06-13T01:21:16+02:00'
fix_commit_message: "btrfs: do not ASSERT() on duplicated global roots\n\n[BUG]\n\
  Syzbot reports a reproducible ASSERT() when using rescue=usebackuproot\nmount option\
  \ on a corrupted fs.\n\nThe full report can be found here:\nhttps://syzkaller.appspot.com/bug?extid=c4614eae20a166c25bf0\n\
  \n  BTRFS error (device loop0: state C): failed to load root csum\n  assertion failed:\
  \ !tmp, in fs/btrfs/disk-io.c:1103\n  ------------[ cut here ]------------\n  kernel\
  \ BUG at fs/btrfs/ctree.h:3664!\n  invalid opcode: 0000 [#1] PREEMPT SMP KASAN\n\
  \  CPU: 1 PID: 3608 Comm: syz-executor356 Not tainted 6.0.0-rc7-syzkaller-00029-g3800a713b607\
  \ #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS\
  \ Google 08/26/2022\n  RIP: 0010:assertfail+0x1a/0x1c fs/btrfs/ctree.h:3663\n  RSP:\
  \ 0018:ffffc90003aaf250 EFLAGS: 00010246\n  RAX: 0000000000000032 RBX: 0000000000000000\
  \ RCX: f21c13f886638400\n  RDX: 0000000000000000 RSI: 0000000080000000 RDI: 0000000000000000\n\
  \  RBP: ffff888021c640a0 R08: ffffffff816bd38d R09: ffffed10173667f1\n  R10: ffffed10173667f1\
  \ R11: 1ffff110173667f0 R12: dffffc0000000000\n  R13: ffff8880229c21f7 R14: ffff888021c64060\
  \ R15: ffff8880226c0000\n  FS:  0000555556a73300(0000) GS:ffff8880b9b00000(0000)\
  \ knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n\
  \  CR2: 000055a2637d7a00 CR3: 00000000709c4000 CR4: 00000000003506e0\n  DR0: 0000000000000000\
  \ DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0\
  \ DR7: 0000000000000400\n  Call Trace:\n   <TASK>\n   btrfs_global_root_insert+0x1a7/0x1b0\
  \ fs/btrfs/disk-io.c:1103\n   load_global_roots_objectid+0x482/0x8c0 fs/btrfs/disk-io.c:2467\n\
  \   load_global_roots fs/btrfs/disk-io.c:2501 [inline]\n   btrfs_read_roots fs/btrfs/disk-io.c:2528\
  \ [inline]\n   init_tree_roots+0xccb/0x203c fs/btrfs/disk-io.c:2939\n   open_ctree+0x1e53/0x33df\
  \ fs/btrfs/disk-io.c:3574\n   btrfs_fill_super+0x1c6/0x2d0 fs/btrfs/super.c:1456\n\
  \   btrfs_mount_root+0x885/0x9a0 fs/btrfs/super.c:1824\n   legacy_get_tree+0xea/0x180\
  \ fs/fs_context.c:610\n   vfs_get_tree+0x88/0x270 fs/super.c:1530\n   fc_mount fs/namespace.c:1043\
  \ [inline]\n   vfs_kern_mount+0xc9/0x160 fs/namespace.c:1073\n   btrfs_mount+0x3d3/0xbb0\
  \ fs/btrfs/super.c:1884\n\n[CAUSE]\nSince the introduction of global roots, we handle\n\
  csum/extent/free-space-tree roots as global roots, even if no\nextent-tree-v2 feature\
  \ is enabled.\n\nSo for regular csum/extent/fst roots, we load them into\nfs_info::global_root_tree\
  \ rb tree.\n\nAnd we should not expect any conflicts in that rb tree, thus we have\
  \ an\nASSERT() inside btrfs_global_root_insert().\n\nBut rescue=usebackuproot can\
  \ break the assumption, as we will try to\nload those trees again and again as long\
  \ as we have bad roots and have\nbackup roots slot remaining.\n\nSo in that case\
  \ we can have conflicting roots in the rb tree, and\ntriggering the ASSERT() crash.\n\
  \n[FIX]\nWe can safely remove that ASSERT(), as the caller will properly put the\n\
  offending root.\n\nTo make further debugging easier, also add two explicit error\
  \ messages:\n\n- Error message for conflicting global roots\n- Error message when\
  \ using backup roots slot\n\nReported-by: syzbot+a694851c6ab28cbcfb9c@syzkaller.appspotmail.com\n\
  Fixes: abed4aaae4f7 (\"btrfs: track the csum, extent, and free space trees in a\
  \ rb tree\")\nCC: stable@vger.kernel.org # 6.1+\nSigned-off-by: Qu Wenruo <wqu@suse.com>\n\
  Reviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>\n"
submodule:
- fs/btrfs
hunk_count: 2
covered_count: 0
