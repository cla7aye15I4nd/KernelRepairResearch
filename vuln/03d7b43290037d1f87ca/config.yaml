id: 03d7b43290037d1f87ca
bug_link: https://syzkaller.appspot.com/bug?extid=03d7b43290037d1f87ca
title: 'KASAN: use-after-free Read in __post_watch_notification'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: e0339f036ef4beb9b20f0b6532a1e0ece7f594c6
fix_commit: e64ab2dbd882933b65cd82ff6235d705ad65dbb6
datetime: '2022-07-28T10:06:49-07:00'
fix_commit_message: 'watch_queue: Fix missing locking in add_watch_to_object()


  If a watch is being added to a queue, it needs to guard against

  interference from addition of a new watch, manual removal of a watch and

  removal of a watch due to some other queue being destroyed.


  KEYCTL_WATCH_KEY guards against this for the same {key,queue} pair by

  holding the key->sem writelocked and by holding refs on both the key and

  the queue - but that doesn''t prevent interaction from other {key,queue}

  pairs.


  While add_watch_to_object() does take the spinlock on the event queue,

  it doesn''t take the lock on the source''s watch list.  The assumption was

  that the caller would prevent that (say by taking key->sem) - but that

  doesn''t prevent interference from the destruction of another queue.


  Fix this by locking the watcher list in add_watch_to_object().


  Fixes: c73be61cede5 ("pipe: Add general notification queue support")

  Reported-by: syzbot+03d7b43290037d1f87ca@syzkaller.appspotmail.com

  Signed-off-by: David Howells <dhowells@redhat.com>

  cc: keyrings@vger.kernel.org

  Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

  '
submodule:
- kernel
hunk_count: 2
covered_count: 2
