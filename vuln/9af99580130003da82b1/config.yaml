id: 9af99580130003da82b1
bug_link: https://syzkaller.appspot.com/bug?extid=9af99580130003da82b1
title: 'KASAN: use-after-free Read in io_wqe_worker'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: dbbe9c642411c359ad0a0e32442eb2e11d3811b5
fix_commit: c4068bf898ddaef791049a366828d9b84b467bda
datetime: '2020-09-30T20:32:34-06:00'
fix_commit_message: "io-wq: fix use-after-free in io_wq_worker_running\n\nThe smart\
  \ syzbot has found a reproducer for the following issue:\n\n ==================================================================\n\
  \ BUG: KASAN: use-after-free in instrument_atomic_write include/linux/instrumented.h:71\
  \ [inline]\n BUG: KASAN: use-after-free in atomic_inc include/asm-generic/atomic-instrumented.h:240\
  \ [inline]\n BUG: KASAN: use-after-free in io_wqe_inc_running fs/io-wq.c:301 [inline]\n\
  \ BUG: KASAN: use-after-free in io_wq_worker_running+0xde/0x110 fs/io-wq.c:613\n\
  \ Write of size 4 at addr ffff8882183db08c by task io_wqe_worker-0/7771\n\n CPU:\
  \ 0 PID: 7771 Comm: io_wqe_worker-0 Not tainted 5.9.0-rc4-syzkaller #0\n Hardware\
  \ name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n\
  \ Call Trace:\n  __dump_stack lib/dump_stack.c:77 [inline]\n  dump_stack+0x198/0x1fd\
  \ lib/dump_stack.c:118\n  print_address_description.constprop.0.cold+0xae/0x497\
  \ mm/kasan/report.c:383\n  __kasan_report mm/kasan/report.c:513 [inline]\n  kasan_report.cold+0x1f/0x37\
  \ mm/kasan/report.c:530\n  check_memory_region_inline mm/kasan/generic.c:186 [inline]\n\
  \  check_memory_region+0x13d/0x180 mm/kasan/generic.c:192\n  instrument_atomic_write\
  \ include/linux/instrumented.h:71 [inline]\n  atomic_inc include/asm-generic/atomic-instrumented.h:240\
  \ [inline]\n  io_wqe_inc_running fs/io-wq.c:301 [inline]\n  io_wq_worker_running+0xde/0x110\
  \ fs/io-wq.c:613\n  schedule_timeout+0x148/0x250 kernel/time/timer.c:1879\n  io_wqe_worker+0x517/0x10e0\
  \ fs/io-wq.c:580\n  kthread+0x3b5/0x4a0 kernel/kthread.c:292\n  ret_from_fork+0x1f/0x30\
  \ arch/x86/entry/entry_64.S:294\n\n Allocated by task 7768:\n  kasan_save_stack+0x1b/0x40\
  \ mm/kasan/common.c:48\n  kasan_set_track mm/kasan/common.c:56 [inline]\n  __kasan_kmalloc.constprop.0+0xbf/0xd0\
  \ mm/kasan/common.c:461\n  kmem_cache_alloc_node_trace+0x17b/0x3f0 mm/slab.c:3594\n\
  \  kmalloc_node include/linux/slab.h:572 [inline]\n  kzalloc_node include/linux/slab.h:677\
  \ [inline]\n  io_wq_create+0x57b/0xa10 fs/io-wq.c:1064\n  io_init_wq_offload fs/io_uring.c:7432\
  \ [inline]\n  io_sq_offload_start fs/io_uring.c:7504 [inline]\n  io_uring_create\
  \ fs/io_uring.c:8625 [inline]\n  io_uring_setup+0x1836/0x28e0 fs/io_uring.c:8694\n\
  \  do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\n  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\
  \n Freed by task 21:\n  kasan_save_stack+0x1b/0x40 mm/kasan/common.c:48\n  kasan_set_track+0x1c/0x30\
  \ mm/kasan/common.c:56\n  kasan_set_free_info+0x1b/0x30 mm/kasan/generic.c:355\n\
  \  __kasan_slab_free+0xd8/0x120 mm/kasan/common.c:422\n  __cache_free mm/slab.c:3418\
  \ [inline]\n  kfree+0x10e/0x2b0 mm/slab.c:3756\n  __io_wq_destroy fs/io-wq.c:1138\
  \ [inline]\n  io_wq_destroy+0x2af/0x460 fs/io-wq.c:1146\n  io_finish_async fs/io_uring.c:6836\
  \ [inline]\n  io_ring_ctx_free fs/io_uring.c:7870 [inline]\n  io_ring_exit_work+0x1e4/0x6d0\
  \ fs/io_uring.c:7954\n  process_one_work+0x94c/0x1670 kernel/workqueue.c:2269\n\
  \  worker_thread+0x64c/0x1120 kernel/workqueue.c:2415\n  kthread+0x3b5/0x4a0 kernel/kthread.c:292\n\
  \  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:294\n\n The buggy address belongs\
  \ to the object at ffff8882183db000\n  which belongs to the cache kmalloc-1k of\
  \ size 1024\n The buggy address is located 140 bytes inside of\n  1024-byte region\
  \ [ffff8882183db000, ffff8882183db400)\n The buggy address belongs to the page:\n\
  \ page:000000009bada22b refcount:1 mapcount:0 mapping:0000000000000000 index:0x0\
  \ pfn:0x2183db\n flags: 0x57ffe0000000200(slab)\n raw: 057ffe0000000200 ffffea0008604c48\
  \ ffffea00086a8648 ffff8880aa040700\n raw: 0000000000000000 ffff8882183db000 0000000100000002\
  \ 0000000000000000\n page dumped because: kasan: bad access detected\n\n Memory\
  \ state around the buggy address:\n  ffff8882183daf80: ff ff ff ff ff ff ff ff ff\
  \ ff ff ff ff ff ff ff\n  ffff8882183db000: fa fb fb fb fb fb fb fb fb fb fb fb\
  \ fb fb fb fb\n >ffff8882183db080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\
  \ fb\n                       ^\n  ffff8882183db100: fb fb fb fb fb fb fb fb fb fb\
  \ fb fb fb fb fb fb\n  ffff8882183db180: fb fb fb fb fb fb fb fb fb fb fb fb fb\
  \ fb fb fb\n ==================================================================\n\
  \nwhich is down to the comment below,\n\n\t/* all workers gone, wq exit can proceed\
  \ */\n\tif (!nr_workers && refcount_dec_and_test(&wqe->wq->refs))\n\t\tcomplete(&wqe->wq->done);\n\
  \nbecause there might be multiple cases of wqe in a wq and we would wait\nfor every\
  \ worker in every wqe to go home before releasing wq's resources\non destroying.\n\
  \nTo that end, rework wq's refcount by making it independent of the tracking\nof\
  \ workers because after all they are two different things, and keeping\nit balanced\
  \ when workers come and go. Note the manager kthread, like\nother workers, now holds\
  \ a grab to wq during its lifetime.\n\nFinally to help destroy wq, check IO_WQ_BIT_EXIT\
  \ upon creating worker\nand do nothing for exiting wq.\n\nCc: stable@vger.kernel.org\
  \ # v5.5+\nReported-by: syzbot+45fa0a195b941764e0f0@syzkaller.appspotmail.com\n\
  Reported-by: syzbot+9af99580130003da82b1@syzkaller.appspotmail.com\nCc: Pavel Begunkov\
  \ <asml.silence@gmail.com>\nSigned-off-by: Hillf Danton <hdanton@sina.com>\nSigned-off-by:\
  \ Jens Axboe <axboe@kernel.dk>\n"
submodule:
- fs
hunk_count: 8
covered_count: 1
