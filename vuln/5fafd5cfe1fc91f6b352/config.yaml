id: 5fafd5cfe1fc91f6b352
bug_link: https://syzkaller.appspot.com/bug?extid=5fafd5cfe1fc91f6b352
title: 'KASAN: use-after-free Read in do_accept'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 208a21107ef0ae86c92078caf84ce80053e73f7a
fix_commit: 409db27e3a2eb5e8ef7226ca33be33361b3ed1c9
datetime: '2023-01-24T11:54:01+01:00'
fix_commit_message: "netrom: Fix use-after-free of a listening socket.\n\nsyzbot reported\
  \ a use-after-free in do_accept(), precisely nr_accept()\nas sk_prot_alloc() allocated\
  \ the memory and sock_put() frees it. [0]\n\nThe issue could happen if the heartbeat\
  \ timer is fired and\nnr_heartbeat_expiry() calls nr_destroy_socket(), where a socket\n\
  has SOCK_DESTROY or a listening socket has SOCK_DEAD.\n\nIn this case, the first\
  \ condition cannot be true.  SOCK_DESTROY is\nflagged in nr_release() only when\
  \ the file descriptor is close()d,\nbut accept() is being called for the listening\
  \ socket, so the second\ncondition must be true.\n\nUsually, the AF_NETROM listener\
  \ neither starts timers nor sets\nSOCK_DEAD.  However, the condition is met if connect()\
  \ fails before\nlisten().  connect() starts the t1 timer and heartbeat timer, and\n\
  t1timer calls nr_disconnect() when timeout happens.  Then, SOCK_DEAD\nis set, and\
  \ if we call listen(), the heartbeat timer calls\nnr_destroy_socket().\n\n  nr_connect\n\
  \    nr_establish_data_link(sk)\n      nr_start_t1timer(sk)\n    nr_start_heartbeat(sk)\n\
  \                                    nr_t1timer_expiry\n                       \
  \               nr_disconnect(sk, ETIMEDOUT)\n                                 \
  \       nr_sk(sk)->state = NR_STATE_0\n                                        sk->sk_state\
  \ = TCP_CLOSE\n                                        sock_set_flag(sk, SOCK_DEAD)\n\
  nr_listen\n  if (sk->sk_state != TCP_LISTEN)\n    sk->sk_state = TCP_LISTEN\n  \
  \                                  nr_heartbeat_expiry\n                       \
  \               switch (nr->state)\n                                      case NR_STATE_0\n\
  \                                        if (sk->sk_state == TCP_LISTEN &&\n   \
  \                                         sock_flag(sk, SOCK_DEAD))\n          \
  \                                nr_destroy_socket(sk)\n\nThis path seems expected,\
  \ and nr_destroy_socket() is called to clean\nup resources.  Initially, there was\
  \ sock_hold() before nr_destroy_socket()\nso that the socket would not be freed,\
  \ but the commit 517a16b1a88b\n(\"netrom: Decrease sock refcount when sock timers\
  \ expire\") accidentally\nremoved it.\n\nTo fix use-after-free, let's add sock_hold().\n\
  \n[0]:\nBUG: KASAN: use-after-free in do_accept+0x483/0x510 net/socket.c:1848\n\
  Read of size 8 at addr ffff88807978d398 by task syz-executor.3/5315\n\nCPU: 0 PID:\
  \ 5315 Comm: syz-executor.3 Not tainted 6.2.0-rc3-syzkaller-00165-gd9fc1511728c\
  \ #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google\
  \ 10/26/2022\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n\
  \ dump_stack_lvl+0xd1/0x138 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:306\
  \ [inline]\n print_report+0x15e/0x461 mm/kasan/report.c:417\n kasan_report+0xbf/0x1f0\
  \ mm/kasan/report.c:517\n do_accept+0x483/0x510 net/socket.c:1848\n __sys_accept4_file\
  \ net/socket.c:1897 [inline]\n __sys_accept4+0x9a/0x120 net/socket.c:1927\n __do_sys_accept\
  \ net/socket.c:1944 [inline]\n __se_sys_accept net/socket.c:1941 [inline]\n __x64_sys_accept+0x75/0xb0\
  \ net/socket.c:1941\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x39/0xb0\
  \ arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nRIP: 0033:0x7fa436a8c0c9\n\
  Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89\
  \ d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3\
  \ 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fa437784168 EFLAGS: 00000246\
  \ ORIG_RAX: 000000000000002b\nRAX: ffffffffffffffda RBX: 00007fa436bac050 RCX: 00007fa436a8c0c9\n\
  RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000005\nRBP: 00007fa436ae7ae9\
  \ R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246\
  \ R12: 0000000000000000\nR13: 00007ffebc6700df R14: 00007fa437784300 R15: 0000000000022000\n\
  \ </TASK>\n\nAllocated by task 5294:\n kasan_save_stack+0x22/0x40 mm/kasan/common.c:45\n\
  \ kasan_set_track+0x25/0x30 mm/kasan/common.c:52\n ____kasan_kmalloc mm/kasan/common.c:371\
  \ [inline]\n ____kasan_kmalloc mm/kasan/common.c:330 [inline]\n __kasan_kmalloc+0xa3/0xb0\
  \ mm/kasan/common.c:380\n kasan_kmalloc include/linux/kasan.h:211 [inline]\n __do_kmalloc_node\
  \ mm/slab_common.c:968 [inline]\n __kmalloc+0x5a/0xd0 mm/slab_common.c:981\n kmalloc\
  \ include/linux/slab.h:584 [inline]\n sk_prot_alloc+0x140/0x290 net/core/sock.c:2038\n\
  \ sk_alloc+0x3a/0x7a0 net/core/sock.c:2091\n nr_create+0xb6/0x5f0 net/netrom/af_netrom.c:433\n\
  \ __sock_create+0x359/0x790 net/socket.c:1515\n sock_create net/socket.c:1566 [inline]\n\
  \ __sys_socket_create net/socket.c:1603 [inline]\n __sys_socket_create net/socket.c:1588\
  \ [inline]\n __sys_socket+0x133/0x250 net/socket.c:1636\n __do_sys_socket net/socket.c:1649\
  \ [inline]\n __se_sys_socket net/socket.c:1647 [inline]\n __x64_sys_socket+0x73/0xb0\
  \ net/socket.c:1647\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x39/0xb0\
  \ arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\n\nFreed\
  \ by task 14:\n kasan_save_stack+0x22/0x40 mm/kasan/common.c:45\n kasan_set_track+0x25/0x30\
  \ mm/kasan/common.c:52\n kasan_save_free_info+0x2b/0x40 mm/kasan/generic.c:518\n\
  \ ____kasan_slab_free mm/kasan/common.c:236 [inline]\n ____kasan_slab_free+0x13b/0x1a0\
  \ mm/kasan/common.c:200\n kasan_slab_free include/linux/kasan.h:177 [inline]\n __cache_free\
  \ mm/slab.c:3394 [inline]\n __do_kmem_cache_free mm/slab.c:3580 [inline]\n __kmem_cache_free+0xcd/0x3b0\
  \ mm/slab.c:3587\n sk_prot_free net/core/sock.c:2074 [inline]\n __sk_destruct+0x5df/0x750\
  \ net/core/sock.c:2166\n sk_destruct net/core/sock.c:2181 [inline]\n __sk_free+0x175/0x460\
  \ net/core/sock.c:2192\n sk_free+0x7c/0xa0 net/core/sock.c:2203\n sock_put include/net/sock.h:1991\
  \ [inline]\n nr_heartbeat_expiry+0x1d7/0x460 net/netrom/nr_timer.c:148\n call_timer_fn+0x1da/0x7c0\
  \ kernel/time/timer.c:1700\n expire_timers+0x2c6/0x5c0 kernel/time/timer.c:1751\n\
  \ __run_timers kernel/time/timer.c:2022 [inline]\n __run_timers kernel/time/timer.c:1995\
  \ [inline]\n run_timer_softirq+0x326/0x910 kernel/time/timer.c:2035\n __do_softirq+0x1fb/0xadc\
  \ kernel/softirq.c:571\n\nFixes: 517a16b1a88b (\"netrom: Decrease sock refcount\
  \ when sock timers expire\")\nReported-by: syzbot+5fafd5cfe1fc91f6b352@syzkaller.appspotmail.com\n\
  Signed-off-by: Kuniyuki Iwashima <kuniyu@amazon.com>\nLink: https://lore.kernel.org/r/20230120231927.51711-1-kuniyu@amazon.com\n\
  Signed-off-by: Paolo Abeni <pabeni@redhat.com>\n"
submodule:
- net/netrom
hunk_count: 1
covered_count: 1
