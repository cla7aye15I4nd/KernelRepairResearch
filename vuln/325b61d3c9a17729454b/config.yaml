id: 325b61d3c9a17729454b
bug_link: https://syzkaller.appspot.com/bug?extid=325b61d3c9a17729454b
title: possible deadlock in hfsplus_file_extend
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: deebbd505c7bf8913451095c3ac9dcec39c7a025
fix_commit: be4edd1642ee205ed7bbf66edc0453b1be1fb8d7
datetime: '2024-06-21T11:41:04+02:00'
fix_commit_message: "hfsplus: fix to avoid false alarm of circular locking\n\nSyzbot\
  \ report potential ABBA deadlock as below:\n\nloop0: detected capacity change from\
  \ 0 to 1024\n======================================================\nWARNING: possible\
  \ circular locking dependency detected\n6.9.0-syzkaller-10323-g8f6a15f095a6 #0 Not\
  \ tainted\n------------------------------------------------------\nsyz-executor171/5344\
  \ is trying to acquire lock:\nffff88807cb980b0 (&tree->tree_lock){+.+.}-{3:3}, at:\
  \ hfsplus_file_truncate+0x811/0xb50 fs/hfsplus/extents.c:595\n\nbut task is already\
  \ holding lock:\nffff88807a930108 (&HFSPLUS_I(inode)->extents_lock){+.+.}-{3:3},\
  \ at: hfsplus_file_truncate+0x2da/0xb50 fs/hfsplus/extents.c:576\n\nwhich lock already\
  \ depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\
  \n-> #1 (&HFSPLUS_I(inode)->extents_lock){+.+.}-{3:3}:\n       lock_acquire+0x1ed/0x550\
  \ kernel/locking/lockdep.c:5754\n       __mutex_lock_common kernel/locking/mutex.c:608\
  \ [inline]\n       __mutex_lock+0x136/0xd70 kernel/locking/mutex.c:752\n       hfsplus_file_extend+0x21b/0x1b70\
  \ fs/hfsplus/extents.c:457\n       hfsplus_bmap_reserve+0x105/0x4e0 fs/hfsplus/btree.c:358\n\
  \       hfsplus_rename_cat+0x1d0/0x1050 fs/hfsplus/catalog.c:456\n       hfsplus_rename+0x12e/0x1c0\
  \ fs/hfsplus/dir.c:552\n       vfs_rename+0xbdb/0xf00 fs/namei.c:4887\n       do_renameat2+0xd94/0x13f0\
  \ fs/namei.c:5044\n       __do_sys_rename fs/namei.c:5091 [inline]\n       __se_sys_rename\
  \ fs/namei.c:5089 [inline]\n       __x64_sys_rename+0x86/0xa0 fs/namei.c:5089\n\
  \       do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n       do_syscall_64+0xf5/0x240\
  \ arch/x86/entry/common.c:83\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n\
  -> #0 (&tree->tree_lock){+.+.}-{3:3}:\n       check_prev_add kernel/locking/lockdep.c:3134\
  \ [inline]\n       check_prevs_add kernel/locking/lockdep.c:3253 [inline]\n    \
  \   validate_chain+0x18cb/0x58e0 kernel/locking/lockdep.c:3869\n       __lock_acquire+0x1346/0x1fd0\
  \ kernel/locking/lockdep.c:5137\n       lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5754\n\
  \       __mutex_lock_common kernel/locking/mutex.c:608 [inline]\n       __mutex_lock+0x136/0xd70\
  \ kernel/locking/mutex.c:752\n       hfsplus_file_truncate+0x811/0xb50 fs/hfsplus/extents.c:595\n\
  \       hfsplus_setattr+0x1ce/0x280 fs/hfsplus/inode.c:265\n       notify_change+0xb9d/0xe70\
  \ fs/attr.c:497\n       do_truncate+0x220/0x310 fs/open.c:65\n       handle_truncate\
  \ fs/namei.c:3308 [inline]\n       do_open fs/namei.c:3654 [inline]\n       path_openat+0x2a3d/0x3280\
  \ fs/namei.c:3807\n       do_filp_open+0x235/0x490 fs/namei.c:3834\n       do_sys_openat2+0x13e/0x1d0\
  \ fs/open.c:1406\n       do_sys_open fs/open.c:1421 [inline]\n       __do_sys_creat\
  \ fs/open.c:1497 [inline]\n       __se_sys_creat fs/open.c:1491 [inline]\n     \
  \  __x64_sys_creat+0x123/0x170 fs/open.c:1491\n       do_syscall_x64 arch/x86/entry/common.c:52\
  \ [inline]\n       do_syscall_64+0xf5/0x240 arch/x86/entry/common.c:83\n       entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\
  \nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\
  \n       CPU0                    CPU1\n       ----                    ----\n  lock(&HFSPLUS_I(inode)->extents_lock);\n\
  \                               lock(&tree->tree_lock);\n                      \
  \         lock(&HFSPLUS_I(inode)->extents_lock);\n  lock(&tree->tree_lock);\n\n\
  This is a false alarm as tree_lock mutex are different, one is\nfrom sbi->cat_tree,\
  \ and another is from sbi->ext_tree:\n\nThread A\t\t\tThread B\n- hfsplus_rename\n\
  \ - hfsplus_rename_cat\n  - hfs_find_init\n   - mutext_lock(cat_tree->tree_lock)\n\
  \t\t\t\t- hfsplus_setattr\n\t\t\t\t - hfsplus_file_truncate\n\t\t\t\t  - mutex_lock(hip->extents_lock)\n\
  \t\t\t\t  - hfs_find_init\n\t\t\t\t   - mutext_lock(ext_tree->tree_lock)\n  - hfs_bmap_reserve\n\
  \   - hfsplus_file_extend\n    - mutex_lock(hip->extents_lock)\n\nSo, let's call\
  \ mutex_lock_nested for tree_lock mutex lock, and pass\ncorrect lock class for it.\n\
  \nFixes: 31651c607151 (\"hfsplus: avoid deadlock on file truncation\")\nReported-by:\
  \ syzbot+6030b3b1b9bf70e538c4@syzkaller.appspotmail.com\nCloses: https://lore.kernel.org/linux-fsdevel/000000000000e37a4005ef129563@google.com\n\
  Cc: Ernesto A. Fern√°ndez <ernesto.mnd.fernandez@gmail.com>\nSigned-off-by: Chao\
  \ Yu <chao@kernel.org>\nLink: https://lore.kernel.org/r/20240607142304.455441-1-chao@kernel.org\n\
  Signed-off-by: Christian Brauner <brauner@kernel.org>\n"
submodule:
- fs/hfsplus
hunk_count: 5
covered_count: 2
