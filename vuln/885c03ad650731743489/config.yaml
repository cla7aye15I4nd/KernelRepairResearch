id: 885c03ad650731743489
bug_link: https://syzkaller.appspot.com/bug?extid=885c03ad650731743489
title: 'BUG: stack guard page was hit in sys_open'
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: aa3956418985bda1f68313eadde3267921847978
fix_commit: 4acb665cf4f3e5436844f17ece0a8a55ce688c7b
datetime: '2024-12-20T22:07:57+01:00'
fix_commit_message: "netfs: Work around recursion by abandoning retry if nothing read\n\
  \nsyzkaller reported recursion with a loop of three calls (netfs_rreq_assess,\n\
  netfs_retry_reads and netfs_rreq_terminated) hitting the limit of the stack\nduring\
  \ an unbuffered or direct I/O read.\n\nThere are a number of issues:\n\n (1) There\
  \ is no limit on the number of retries.\n\n (2) A subrequest is supposed to be abandoned\
  \ if it does not transfer\n     anything (NETFS_SREQ_NO_PROGRESS), but that isn't\
  \ checked under all\n     circumstances.\n\n (3) The actual root cause, which is\
  \ this:\n\n\tif (atomic_dec_and_test(&rreq->nr_outstanding))\n\t\tnetfs_rreq_terminated(rreq,\
  \ ...);\n\n     When we do a retry, we bump the rreq->nr_outstanding counter to\n\
  \     prevent the final cleanup phase running before we've finished\n     dispatching\
  \ the retries.  The problem is if we hit 0, we have to do\n     the cleanup phase\
  \ - but we're in the cleanup phase and end up\n     repeating the retry cycle, hence\
  \ the recursion.\n\nWork around the problem by limiting the number of retries. \
  \ This is based\non Lizhi Xu's patch[1], and makes the following changes:\n\n (1)\
  \ Replace NETFS_SREQ_NO_PROGRESS with NETFS_SREQ_MADE_PROGRESS and make\n     the\
  \ filesystem set it if it managed to read or write at least one byte\n     of data.\
  \  Clear this bit before issuing a subrequest.\n\n (2) Add a ->retry_count member\
  \ to the subrequest and increment it any time\n     we do a retry.\n\n (3) Remove\
  \ the NETFS_SREQ_RETRYING flag as it is superfluous with\n     ->retry_count.  If\
  \ the latter is non-zero, we're doing a retry.\n\n (4) Abandon a subrequest if retry_count\
  \ is non-zero and we made no\n     progress.\n\n (5) Use ->retry_count in both the\
  \ write-side and the read-size.\n\n[?] Question: Should I set a hard limit on retry_count\
  \ in both read and\n    write?  Say it hits 50, we always abandon it.  The problem\
  \ is that\n    these changes only mitigate the issue.  As long as it made at least\
  \ one\n    byte of progress, the recursion is still an issue.  This patch\n    mitigates\
  \ the problem, but does not fix the underlying cause.  I have\n    patches that\
  \ will do that, but it's an intrusive fix that's currently\n    pending for the\
  \ next merge window.\n\nThe oops generated by KASAN looks something like:\n\n  \
  \ BUG: TASK stack guard page was hit at ffffc9000482ff48 (stack is ffffc90004830000..ffffc90004838000)\n\
  \   Oops: stack guard page: 0000 [#1] PREEMPT SMP KASAN NOPTI\n   ...\n   RIP: 0010:mark_lock+0x25/0xc60\
  \ kernel/locking/lockdep.c:4686\n    ...\n    mark_usage kernel/locking/lockdep.c:4646\
  \ [inline]\n    __lock_acquire+0x906/0x3ce0 kernel/locking/lockdep.c:5156\n    lock_acquire.part.0+0x11b/0x380\
  \ kernel/locking/lockdep.c:5825\n    local_lock_acquire include/linux/local_lock_internal.h:29\
  \ [inline]\n    ___slab_alloc+0x123/0x1880 mm/slub.c:3695\n    __slab_alloc.constprop.0+0x56/0xb0\
  \ mm/slub.c:3908\n    __slab_alloc_node mm/slub.c:3961 [inline]\n    slab_alloc_node\
  \ mm/slub.c:4122 [inline]\n    kmem_cache_alloc_noprof+0x2a7/0x2f0 mm/slub.c:4141\n\
  \    radix_tree_node_alloc.constprop.0+0x1e8/0x350 lib/radix-tree.c:253\n    idr_get_free+0x528/0xa40\
  \ lib/radix-tree.c:1506\n    idr_alloc_u32+0x191/0x2f0 lib/idr.c:46\n    idr_alloc+0xc1/0x130\
  \ lib/idr.c:87\n    p9_tag_alloc+0x394/0x870 net/9p/client.c:321\n    p9_client_prepare_req+0x19f/0x4d0\
  \ net/9p/client.c:644\n    p9_client_zc_rpc.constprop.0+0x105/0x880 net/9p/client.c:793\n\
  \    p9_client_read_once+0x443/0x820 net/9p/client.c:1570\n    p9_client_read+0x13f/0x1b0\
  \ net/9p/client.c:1534\n    v9fs_issue_read+0x115/0x310 fs/9p/vfs_addr.c:74\n  \
  \  netfs_retry_read_subrequests fs/netfs/read_retry.c:60 [inline]\n    netfs_retry_reads+0x153a/0x1d00\
  \ fs/netfs/read_retry.c:232\n    netfs_rreq_assess+0x5d3/0x870 fs/netfs/read_collect.c:371\n\
  \    netfs_rreq_terminated+0xe5/0x110 fs/netfs/read_collect.c:407\n    netfs_retry_reads+0x155e/0x1d00\
  \ fs/netfs/read_retry.c:235\n    netfs_rreq_assess+0x5d3/0x870 fs/netfs/read_collect.c:371\n\
  \    netfs_rreq_terminated+0xe5/0x110 fs/netfs/read_collect.c:407\n    netfs_retry_reads+0x155e/0x1d00\
  \ fs/netfs/read_retry.c:235\n    netfs_rreq_assess+0x5d3/0x870 fs/netfs/read_collect.c:371\n\
  \    ...\n    netfs_rreq_terminated+0xe5/0x110 fs/netfs/read_collect.c:407\n   \
  \ netfs_retry_reads+0x155e/0x1d00 fs/netfs/read_retry.c:235\n    netfs_rreq_assess+0x5d3/0x870\
  \ fs/netfs/read_collect.c:371\n    netfs_rreq_terminated+0xe5/0x110 fs/netfs/read_collect.c:407\n\
  \    netfs_retry_reads+0x155e/0x1d00 fs/netfs/read_retry.c:235\n    netfs_rreq_assess+0x5d3/0x870\
  \ fs/netfs/read_collect.c:371\n    netfs_rreq_terminated+0xe5/0x110 fs/netfs/read_collect.c:407\n\
  \    netfs_dispatch_unbuffered_reads fs/netfs/direct_read.c:103 [inline]\n    netfs_unbuffered_read\
  \ fs/netfs/direct_read.c:127 [inline]\n    netfs_unbuffered_read_iter_locked+0x12f6/0x19b0\
  \ fs/netfs/direct_read.c:221\n    netfs_unbuffered_read_iter+0xc5/0x100 fs/netfs/direct_read.c:256\n\
  \    v9fs_file_read_iter+0xbf/0x100 fs/9p/vfs_file.c:361\n    do_iter_readv_writev+0x614/0x7f0\
  \ fs/read_write.c:832\n    vfs_readv+0x4cf/0x890 fs/read_write.c:1025\n    do_preadv\
  \ fs/read_write.c:1142 [inline]\n    __do_sys_preadv fs/read_write.c:1192 [inline]\n\
  \    __se_sys_preadv fs/read_write.c:1187 [inline]\n    __x64_sys_preadv+0x22d/0x310\
  \ fs/read_write.c:1187\n    do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n\
  \    do_syscall_64+0xcd/0x250 arch/x86/entry/common.c:83\n\nFixes: ee4cdf7ba857\
  \ (\"netfs: Speed up buffered reading\")\nCloses: https://syzkaller.appspot.com/bug?extid=1fc6f64c40a9d143cfb6\n\
  Signed-off-by: David Howells <dhowells@redhat.com>\nLink: https://lore.kernel.org/r/20241108034020.3695718-1-lizhi.xu@windriver.com/\
  \ [1]\nLink: https://lore.kernel.org/r/20241213135013.2964079-9-dhowells@redhat.com\n\
  Tested-by: syzbot+885c03ad650731743489@syzkaller.appspotmail.com\nSuggested-by:\
  \ Lizhi Xu <lizhi.xu@windriver.com>\ncc: Dominique Martinet <asmadeus@codewreck.org>\n\
  cc: Jeff Layton <jlayton@kernel.org>\ncc: v9fs@lists.linux.dev\ncc: netfs@lists.linux.dev\n\
  cc: linux-fsdevel@vger.kernel.org\nReported-by: syzbot+885c03ad650731743489@syzkaller.appspotmail.com\n\
  Signed-off-by: Christian Brauner <brauner@kernel.org>\n"
submodule:
- fs/9p
- fs/afs
- fs/netfs
- fs/smb
- include/linux
hunk_count: 21
covered_count: 5
