id: 2f8fa4e860edc3066aba
bug_link: https://syzkaller.appspot.com/bug?extid=2f8fa4e860edc3066aba
title: possible deadlock in io_write
source_page: https://syzkaller.appspot.com/upstream/fixed
trigger_commit: 8706e04ed7d6c95004d42b22a4db97d5b2eb73b2
fix_commit: fad8e0de4426a776c9bcb060555e7c09e2d08db6
datetime: '2020-09-28T09:06:08-06:00'
fix_commit_message: "io_uring: fix potential ABBA deadlock in ->show_fdinfo()\n\n\
  syzbot reports a potential lock deadlock between the normal IO path and\n->show_fdinfo():\n\
  \n======================================================\nWARNING: possible circular\
  \ locking dependency detected\n5.9.0-rc6-syzkaller #0 Not tainted\n------------------------------------------------------\n\
  syz-executor.2/19710 is trying to acquire lock:\nffff888098ddc450 (sb_writers#4){.+.+}-{0:0},\
  \ at: io_write+0x6b5/0xb30 fs/io_uring.c:3296\n\nbut task is already holding lock:\n\
  ffff8880a11b8428 (&ctx->uring_lock){+.+.}-{3:3}, at: __do_sys_io_uring_enter+0xe9a/0x1bd0\
  \ fs/io_uring.c:8348\n\nwhich lock already depends on the new lock.\n\nthe existing\
  \ dependency chain (in reverse order) is:\n\n-> #2 (&ctx->uring_lock){+.+.}-{3:3}:\n\
  \       __mutex_lock_common kernel/locking/mutex.c:956 [inline]\n       __mutex_lock+0x134/0x10e0\
  \ kernel/locking/mutex.c:1103\n       __io_uring_show_fdinfo fs/io_uring.c:8417\
  \ [inline]\n       io_uring_show_fdinfo+0x194/0xc70 fs/io_uring.c:8460\n       seq_show+0x4a8/0x700\
  \ fs/proc/fd.c:65\n       seq_read+0x432/0x1070 fs/seq_file.c:208\n       do_loop_readv_writev\
  \ fs/read_write.c:734 [inline]\n       do_loop_readv_writev fs/read_write.c:721\
  \ [inline]\n       do_iter_read+0x48e/0x6e0 fs/read_write.c:955\n       vfs_readv+0xe5/0x150\
  \ fs/read_write.c:1073\n       kernel_readv fs/splice.c:355 [inline]\n       default_file_splice_read.constprop.0+0x4e6/0x9e0\
  \ fs/splice.c:412\n       do_splice_to+0x137/0x170 fs/splice.c:871\n       splice_direct_to_actor+0x307/0x980\
  \ fs/splice.c:950\n       do_splice_direct+0x1b3/0x280 fs/splice.c:1059\n      \
  \ do_sendfile+0x55f/0xd40 fs/read_write.c:1540\n       __do_sys_sendfile64 fs/read_write.c:1601\
  \ [inline]\n       __se_sys_sendfile64 fs/read_write.c:1587 [inline]\n       __x64_sys_sendfile64+0x1cc/0x210\
  \ fs/read_write.c:1587\n       do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\n\
  \       entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n-> #1 (&p->lock){+.+.}-{3:3}:\n\
  \       __mutex_lock_common kernel/locking/mutex.c:956 [inline]\n       __mutex_lock+0x134/0x10e0\
  \ kernel/locking/mutex.c:1103\n       seq_read+0x61/0x1070 fs/seq_file.c:155\n \
  \      pde_read fs/proc/inode.c:306 [inline]\n       proc_reg_read+0x221/0x300 fs/proc/inode.c:318\n\
  \       do_loop_readv_writev fs/read_write.c:734 [inline]\n       do_loop_readv_writev\
  \ fs/read_write.c:721 [inline]\n       do_iter_read+0x48e/0x6e0 fs/read_write.c:955\n\
  \       vfs_readv+0xe5/0x150 fs/read_write.c:1073\n       kernel_readv fs/splice.c:355\
  \ [inline]\n       default_file_splice_read.constprop.0+0x4e6/0x9e0 fs/splice.c:412\n\
  \       do_splice_to+0x137/0x170 fs/splice.c:871\n       splice_direct_to_actor+0x307/0x980\
  \ fs/splice.c:950\n       do_splice_direct+0x1b3/0x280 fs/splice.c:1059\n      \
  \ do_sendfile+0x55f/0xd40 fs/read_write.c:1540\n       __do_sys_sendfile64 fs/read_write.c:1601\
  \ [inline]\n       __se_sys_sendfile64 fs/read_write.c:1587 [inline]\n       __x64_sys_sendfile64+0x1cc/0x210\
  \ fs/read_write.c:1587\n       do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\n\
  \       entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n-> #0 (sb_writers#4){.+.+}-{0:0}:\n\
  \       check_prev_add kernel/locking/lockdep.c:2496 [inline]\n       check_prevs_add\
  \ kernel/locking/lockdep.c:2601 [inline]\n       validate_chain kernel/locking/lockdep.c:3218\
  \ [inline]\n       __lock_acquire+0x2a96/0x5780 kernel/locking/lockdep.c:4441\n\
  \       lock_acquire+0x1f3/0xaf0 kernel/locking/lockdep.c:5029\n       percpu_down_read\
  \ include/linux/percpu-rwsem.h:51 [inline]\n       __sb_start_write+0x228/0x450\
  \ fs/super.c:1672\n       io_write+0x6b5/0xb30 fs/io_uring.c:3296\n       io_issue_sqe+0x18f/0x5c50\
  \ fs/io_uring.c:5719\n       __io_queue_sqe+0x280/0x1160 fs/io_uring.c:6175\n  \
  \     io_queue_sqe+0x692/0xfa0 fs/io_uring.c:6254\n       io_submit_sqe fs/io_uring.c:6324\
  \ [inline]\n       io_submit_sqes+0x1761/0x2400 fs/io_uring.c:6521\n       __do_sys_io_uring_enter+0xeac/0x1bd0\
  \ fs/io_uring.c:8349\n       do_syscall_64+0x2d/0x70 arch/x86/entry/common.c:46\n\
  \       entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nother info that might help us\
  \ debug this:\n\nChain exists of:\n  sb_writers#4 --> &p->lock --> &ctx->uring_lock\n\
  \n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n  \
  \     ----                    ----\n  lock(&ctx->uring_lock);\n                \
  \               lock(&p->lock);\n                               lock(&ctx->uring_lock);\n\
  \  lock(sb_writers#4);\n\n *** DEADLOCK ***\n\n1 lock held by syz-executor.2/19710:\n\
  \ #0: ffff8880a11b8428 (&ctx->uring_lock){+.+.}-{3:3}, at: __do_sys_io_uring_enter+0xe9a/0x1bd0\
  \ fs/io_uring.c:8348\n\nstack backtrace:\nCPU: 0 PID: 19710 Comm: syz-executor.2\
  \ Not tainted 5.9.0-rc6-syzkaller #0\nHardware name: Google Google Compute Engine/Google\
  \ Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n __dump_stack lib/dump_stack.c:77\
  \ [inline]\n dump_stack+0x198/0x1fd lib/dump_stack.c:118\n check_noncircular+0x324/0x3e0\
  \ kernel/locking/lockdep.c:1827\n check_prev_add kernel/locking/lockdep.c:2496 [inline]\n\
  \ check_prevs_add kernel/locking/lockdep.c:2601 [inline]\n validate_chain kernel/locking/lockdep.c:3218\
  \ [inline]\n __lock_acquire+0x2a96/0x5780 kernel/locking/lockdep.c:4441\n lock_acquire+0x1f3/0xaf0\
  \ kernel/locking/lockdep.c:5029\n percpu_down_read include/linux/percpu-rwsem.h:51\
  \ [inline]\n __sb_start_write+0x228/0x450 fs/super.c:1672\n io_write+0x6b5/0xb30\
  \ fs/io_uring.c:3296\n io_issue_sqe+0x18f/0x5c50 fs/io_uring.c:5719\n __io_queue_sqe+0x280/0x1160\
  \ fs/io_uring.c:6175\n io_queue_sqe+0x692/0xfa0 fs/io_uring.c:6254\n io_submit_sqe\
  \ fs/io_uring.c:6324 [inline]\n io_submit_sqes+0x1761/0x2400 fs/io_uring.c:6521\n\
  \ __do_sys_io_uring_enter+0xeac/0x1bd0 fs/io_uring.c:8349\n do_syscall_64+0x2d/0x70\
  \ arch/x86/entry/common.c:46\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\nRIP: 0033:0x45e179\n\
  Code: 3d b2 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89\
  \ d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 0b\
  \ b2 fb ff c3 66 2e 0f 1f 84 00 00 00 00\nRSP: 002b:00007f1194e74c78 EFLAGS: 00000246\
  \ ORIG_RAX: 00000000000001aa\nRAX: ffffffffffffffda RBX: 00000000000082c0 RCX: 000000000045e179\n\
  RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000004\nRBP: 000000000118cf98\
  \ R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246\
  \ R12: 000000000118cf4c\nR13: 00007ffd1aa5756f R14: 00007f1194e759c0 R15: 000000000118cf4c\n\
  \nFix this by just not diving into details if we fail to trylock the\nio_uring mutex.\
  \ We know the ctx isn't going away during this operation,\nbut we cannot safely\
  \ iterate buffers/files/personalities if we don't\nhold the io_uring mutex.\n\n\
  Reported-by: syzbot+2f8fa4e860edc3066aba@syzkaller.appspotmail.com\nSigned-off-by:\
  \ Jens Axboe <axboe@kernel.dk>\n"
submodule:
- fs
hunk_count: 3
covered_count: 3
